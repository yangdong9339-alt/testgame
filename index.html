<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>ARCANE EXTRACTION v2 r1772177614</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Share+Tech+Mono&display=swap');
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{background:#ebe9e0;display:flex;align-items:center;justify-content:center;width:100vw;height:100vh;font-family:'Share Tech Mono',monospace;overflow:hidden;color:#1a1a18;touch-action:none}
#app{position:absolute;width:900px;height:600px;background:#f7f6f0;transform-origin:top left;box-shadow:0 8px 40px rgba(0,0,0,0.18)}
canvas{display:block}

/* â”€â”€ HUD â”€â”€ */
#hud{position:absolute;inset:0;pointer-events:none}
#top-bar{position:absolute;top:0;left:0;right:0;height:36px;background:rgba(10,10,16,0.72);display:flex;align-items:center;padding:0 14px;gap:16px;border-bottom:1px solid #2a2a3a}
#zone-label{font-family:'Cinzel',serif;font-size:10px;color:#6a6880;letter-spacing:3px;flex:1;text-align:center}
.stat-block{display:flex;flex-direction:column;gap:2px;min-width:110px}
.bar-label{font-size:6px;color:#5a5870;letter-spacing:2px}
.bar-bg{height:5px;background:#1e1e2c;border:1px solid #2e2e42;position:relative;border-radius:2px}
.bar-fill{height:100%;border-radius:2px;transition:width .15s}
#hp-fill{background:linear-gradient(90deg,#dc2626,#f87171)}

#gold-display{font-size:11px;color:#d97706;white-space:nowrap;font-weight:bold}

/* æˆ˜æ–—æ—¥å¿— å·¦ä¸Š */
#log{position:absolute;top:42px;left:10px;width:210px;max-height:80px;overflow:hidden;display:flex;flex-direction:column;gap:1px;pointer-events:none}
.log-line{font-size:8px;color:#6a6880;line-height:1.4;animation:fadeIn .3s}
.log-line.imp{color:#d97706}.log-line.dmg{color:#f87171}.log-line.loot{color:#4ade80}.log-line.info{color:#67e8f9}
@keyframes fadeIn{from{opacity:0;transform:translateY(3px)}to{opacity:1;transform:none}}

/* å°åœ°å›¾ å³ä¸Š */
#minimap{position:absolute;top:42px;right:10px;width:90px;height:90px;border:1px solid #2a2a3a;background:#0c0c18;pointer-events:none;border-radius:3px}

/* é«˜åº¦æ ‡è®° å°åœ°å›¾ä¸‹æ–¹ */
#elev-badge{position:absolute;top:138px;right:10px;font-size:7px;letter-spacing:2px;text-align:right;pointer-events:none}

/* æ‹¾å–è¿›åº¦æ¡ åº•éƒ¨ä¸­å¤® */
#pickup-bar-wrap{position:absolute;bottom:60px;left:50%;transform:translateX(-50%);width:180px;display:none;flex-direction:column;align-items:center;gap:4px;pointer-events:none}
#pickup-label{font-size:8px;color:#fbbf24;letter-spacing:2px}
#pickup-bg{width:180px;height:6px;background:#1e1e2c;border:1px solid #2e2e42;border-radius:3px}
#pickup-fill{height:100%;background:linear-gradient(90deg,#d97706,#fbbf24);width:0%;border-radius:3px}

/* æ­¦å™¨ä¿¡æ¯ å·¦ä¸‹ */
#weapon-hud{position:absolute;bottom:10px;left:10px;padding:6px 10px;border:1px solid #2a2a3a;background:rgba(10,10,16,0.88);pointer-events:none;min-width:120px;border-radius:4px}
#weapon-name{font-size:9px;color:#d97706;font-family:'Cinzel',serif;margin-bottom:2px}
#weapon-stats{font-size:7px;color:#5a5870;line-height:1.6}

/* â”€â”€ å³ä¾§é¢æ¿ç³»ç»Ÿ â”€â”€ */
#side-panel{position:absolute;bottom:10px;right:10px;display:flex;flex-direction:row;align-items:flex-end;gap:4px;pointer-events:all}

/* Tab æŒ‰é’®åˆ—ï¼ˆå§‹ç»ˆå¯è§ï¼‰ */
#side-tabs{display:flex;flex-direction:column;gap:4px}
.side-tab{width:36px;height:36px;background:rgba(10,10,16,0.88);border:1px solid #2e2e42;border-radius:6px;cursor:pointer;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:14px;color:#5a5870;transition:all .15s;line-height:1;gap:1px;padding:0}
.side-tab span:last-child{font-size:5px;letter-spacing:0.5px;font-family:'Share Tech Mono',monospace;color:#3a3a52}
.side-tab:hover,.side-tab.active{border-color:#d97706;background:rgba(18,18,28,0.96);color:#d97706}
.side-tab.active span:last-child{color:#d97706}

/* é¢æ¿å†…å®¹ï¼ˆæ”¶èµ·æ—¶éšè—ï¼‰ */
.side-content{background:rgba(10,10,16,0.94);border:1px solid #2e2e42;padding:8px;border-radius:6px;box-shadow:0 4px 20px rgba(0,0,0,0.5);width:220px}
.raid-panel-title{font-size:6px;color:#4a4a62;letter-spacing:2px;margin-bottom:6px;border-bottom:1px solid #1e1e2e;padding-bottom:3px;text-transform:uppercase}

/* è£…å¤‡æ§½ */
#raid-equip-grid{display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-bottom:2px}
.req-slot{background:#12121e;border:1px solid #22223a;border-radius:4px;padding:4px 5px;cursor:pointer;display:flex;align-items:center;gap:4px;min-height:34px;transition:border-color .15s}
.req-slot:hover{border-color:#d97706}
.req-slot.filled{border-color:#15803d44;background:#0e1e14}
.req-icon{font-size:13px;flex-shrink:0}
.req-info{flex:1;min-width:0}
.req-label{font-size:5px;color:#3a3a52;letter-spacing:1px;display:block;text-transform:uppercase}
.req-name{font-size:7px;color:#b0b0cc;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:block;margin-top:1px}
.req-stat{font-size:5px;color:#5a5a78;margin-top:1px;display:block}

/* èƒŒåŒ…æ ¼å­ */
#inv-grid{display:grid;grid-template-columns:repeat(5,36px);grid-template-rows:repeat(4,36px);gap:2px;position:relative;margin-bottom:6px}
.inv-cell{width:36px;height:36px;border:1px solid #1e1e2e;background:#0c0c18;position:relative;border-radius:2px}
.inv-item-block{position:absolute;border:1px solid;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:15px;cursor:pointer;z-index:2;border-radius:2px}
.inv-item-block:hover{filter:brightness(1.15)}
.inv-item-block.selected{box-shadow:0 0 0 2px #d97706}
.inv-item-block.is-equipped{box-shadow:0 0 0 2px #4ade80}
.inv-item-name{font-size:5px;color:#ffffff55;line-height:1;padding:0 1px;text-align:center;overflow:hidden;max-width:100%}
#inv-actions{display:flex;gap:3px;margin-top:2px}
.inv-btn{flex:1;padding:4px 2px;font-family:'Share Tech Mono',monospace;font-size:7px;background:none;border:1px solid #2e2e42;color:#8080a0;cursor:pointer;letter-spacing:1px;border-radius:3px;transition:all .12s}
.inv-btn:hover{border-color:#d97706;color:#d97706}
.inv-btn:disabled{opacity:.2;cursor:default}

/* æˆ˜åˆ©å“æ ¼å­ */
#loot-grid{display:grid;grid-template-columns:repeat(4,46px);gap:3px;margin-bottom:6px;max-height:200px;overflow-y:auto}
.loot-cell{width:46px;height:46px;border:1px solid #1e1e2e;background:#0c0c18;border-radius:3px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;position:relative;font-size:17px;transition:border-color .12s}
.loot-cell:hover{border-color:#d97706;background:#14141e}
.loot-cell.selected{border-color:#d97706;background:#1a1420}
.loot-cell .lc-name{font-size:5px;color:#5a5a78;position:absolute;bottom:2px;width:100%;text-align:center;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;padding:0 2px}
.loot-cell .lc-qty{position:absolute;top:2px;right:3px;font-size:6px;color:#fbbf24;font-weight:bold}
#loot-actions{display:flex;gap:3px}

/* â”€â”€ HOMEBASE SCREEN â”€â”€ */
#homebase{position:absolute;inset:0;background:#f7f6f0;display:none;flex-direction:column}
#hb-header{background:#ffffff;border-bottom:1px solid #e5e4de;padding:12px 20px;display:flex;align-items:center;gap:20px}
#hb-title{font-family:'Cinzel',serif;font-size:16px;color:#1a1a18;letter-spacing:4px}
#hb-gold{font-size:12px;color:#d97706;font-weight:bold}
#hb-btn-raid{margin-left:auto;padding:8px 20px;background:#d97706;border:none;color:#ffffff;font-family:'Share Tech Mono',monospace;font-size:10px;cursor:pointer;letter-spacing:2px;border-radius:4px}
#hb-btn-raid:hover{background:#b45309}
#hb-body{display:flex;flex:1;overflow:hidden}
#hb-storage{flex:1;padding:16px;border-right:1px solid #e5e4de;overflow-y:auto;background:#f7f6f0}
#hb-market{width:280px;padding:16px;overflow-y:auto;background:#ffffff}
.hb-section-title{font-size:9px;color:#9a9488;letter-spacing:3px;margin-bottom:10px;border-bottom:1px solid #e5e4de;padding-bottom:4px;text-transform:uppercase}
#storage-grid{display:grid;grid-template-columns:repeat(5,54px);gap:4px}
.storage-slot{width:54px;height:54px;border:1px solid #e5e4de;background:#f0efe9;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:18px;cursor:pointer;position:relative;border-radius:4px}
.storage-slot:hover{border-color:#d0cfc8;background:#ebe9e0}
.storage-slot .slot-name{font-size:6px;color:#9a9488;text-align:center;position:absolute;bottom:3px;width:100%;padding:0 2px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.storage-slot.occupied{border-color:#d0cfc8;background:#ffffff}
.storage-slot.selected-storage{border-color:#d97706!important;box-shadow:0 0 0 2px #d9770644}
#market-list{display:flex;flex-direction:column;gap:4px}
.market-item{display:flex;align-items:center;gap:8px;padding:6px 8px;border:1px solid #e5e4de;background:#f7f6f0;cursor:pointer;border-radius:4px}
.market-item:hover{border-color:#d0cfc8;background:#f0efe9}
.market-item .mi-icon{font-size:16px;width:24px;text-align:center}
.market-item .mi-info{flex:1}
.market-item .mi-name{font-size:8px;color:#1a1a18}
.market-item .mi-price{font-size:7px;color:#6b6860;margin-top:2px}
.market-item .mi-price .price-val{color:#d97706;font-weight:bold}
.market-item .mi-price .price-trend{font-size:6px}
.market-item .mi-price .up{color:#15803d}.market-item .mi-price .down{color:#dc2626}
.market-item .mi-action{font-size:7px;padding:3px 8px;background:none;border:1px solid;cursor:pointer;font-family:'Share Tech Mono',monospace;border-radius:3px}
.mi-sell{border-color:#15803d88;color:#15803d}.mi-sell:hover{background:#15803d15}
.mi-buy{border-color:#7c3aed88;color:#7c3aed}.mi-buy:hover{background:#7c3aed15}
.mi-sell:disabled,.mi-buy:disabled{opacity:.3;cursor:default}
#hb-storage-actions{display:flex;gap:6px;margin-top:8px}
.hb-action-btn{padding:4px 10px;background:none;border:1px solid #d0cfc8;color:#1a1a18;font-family:'Share Tech Mono',monospace;font-size:8px;cursor:pointer;border-radius:3px}
.hb-action-btn:hover{border-color:#d97706;color:#d97706}
.hb-action-btn:disabled{opacity:.3;cursor:default}

/* â”€â”€ HOMEBASE LOADOUT REDESIGN â”€â”€ */
#hb-body{display:flex;flex:1;overflow:hidden}
#hb-storage{width:280px;padding:12px;border-right:1px solid #e5e4de;overflow-y:auto;flex-shrink:0;background:#f7f6f0}
#hb-loadout{width:260px;padding:12px;border-right:1px solid #e5e4de;overflow-y:auto;flex-shrink:0;background:#faf9f5}
#hb-market{flex:1;padding:12px;overflow-y:auto;background:#ffffff}

/* Equipment slots */
#equip-slots-row{display:flex;gap:8px;flex-wrap:wrap}
.equip-slot-wrap{display:flex;flex-direction:column;align-items:center;gap:3px}
.equip-slot-label{font-size:6px;color:#9a9488;letter-spacing:1px;text-transform:uppercase}
.equip-slot{width:52px;height:52px;border:1px solid #e5e4de;background:#f7f6f0;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;position:relative;transition:all .15s;border-radius:6px}
.equip-slot:hover{border-color:#d0cfc8;background:#ebe9e0}
.equip-slot.filled{border-color:#15803d44;background:#f0fdf4}
.equip-slot.selected{border-color:#d97706;box-shadow:0 0 0 2px #d9770622}
.equip-slot .eslot-empty{font-size:18px;color:#d0cfc8}
.equip-slot .eslot-icon{font-size:20px;line-height:1}
.equip-slot .eslot-name{font-size:5px;color:#15803d;text-align:center;padding:0 2px;line-height:1.2;overflow:hidden;max-width:50px}
.equip-slot .eslot-del{position:absolute;top:2px;right:3px;font-size:6px;color:#c0beb6;cursor:pointer}
.equip-slot .eslot-del:hover{color:#dc2626}

/* Ammo slots */
#ammo-slots-row{display:flex;gap:6px;flex-wrap:wrap}
.ammo-slot{width:52px;height:52px;border:1px dashed #d0cfc8;background:#f7f6f0;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;position:relative;transition:all .15s;gap:2px;border-radius:6px}
.ammo-slot:hover{border-color:#9a9488}
.ammo-slot.filled{border-style:solid;border-color:#7c3aed44;background:#faf5ff}
.ammo-slot.selected{border-color:#d97706;box-shadow:0 0 0 2px #d9770622}
.ammo-slot .aslot-empty{font-size:14px;color:#d0cfc8}
.ammo-slot .aslot-icon{font-size:18px;line-height:1}
.ammo-slot .aslot-count{font-size:9px;font-weight:bold;line-height:1}
.ammo-slot .aslot-name{font-size:5px;color:#6b6860;text-align:center;padding:0 1px;line-height:1.1}
.ammo-slot .aslot-del{position:absolute;top:2px;right:3px;font-size:6px;color:#c0beb6;cursor:pointer}
.ammo-slot .aslot-del:hover{color:#dc2626}

/* Loadout bag grid */
#loadout-grid{display:grid;grid-template-columns:repeat(4,52px);gap:4px;margin-top:6px}
.loadout-slot{width:52px;height:52px;border:1px dashed #d0cfc8;background:#f7f6f0;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:16px;cursor:pointer;position:relative;border-radius:4px}
.loadout-slot:hover{border-color:#9a9488;background:#ebe9e0}
.loadout-slot .slot-name{font-size:5px;color:#9a9488;position:absolute;bottom:3px;width:100%;text-align:center;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.loadout-slot.occupied{border-style:solid;border-color:#d0cfc8;background:#ffffff}
.loadout-slot.selected-loadout{border-color:#d97706!important}


/* â”€â”€ OVERLAY SCREENS â”€â”€ */
.overlay-screen{position:absolute;inset:0;background:rgba(247,246,240,0.96);display:none;flex-direction:column;align-items:center;justify-content:center;gap:14px}
.overlay-screen h1{font-family:'Cinzel',serif;letter-spacing:6px;color:#1a1a18}
.overlay-screen p{font-size:10px;color:#6b6860}
.overlay-screen button{padding:8px 24px;background:#1a1a18;border:none;color:#f7f6f0;font-family:'Share Tech Mono',monospace;font-size:10px;cursor:pointer;letter-spacing:2px;border-radius:4px}
.overlay-screen button:hover{background:#333}
#death-screen h1{color:#dc2626}
#extract-screen h1{color:#15803d;font-size:22px}
#extract-screen .summary{font-size:9px;color:#6b6860;text-align:center;line-height:2.2}
#extract-screen button{background:#15803d}

/* â”€â”€ TOUCH CONTROLS â”€â”€ */
#touch-zone{position:absolute;inset:0;pointer-events:none}
#joystick-base{position:absolute;width:100px;height:100px;border-radius:50%;background:rgba(255,255,255,.05);border:1.5px solid rgba(255,255,255,.1);bottom:100px;left:30px;pointer-events:all;display:none}
#joystick-knob{width:40px;height:40px;border-radius:50%;background:rgba(255,255,255,.18);border:1.5px solid rgba(255,255,255,.3);position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}
#touch-btns{position:absolute;bottom:100px;right:10px;display:none;flex-direction:column;gap:8px;pointer-events:all}
.tbtn{width:60px;height:60px;border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:7px;border:1.5px solid;cursor:pointer;letter-spacing:1px;gap:2px}
#tbtn-pickup{background:rgba(251,191,36,.12);border-color:rgba(251,191,36,.4);color:#fbbf24}
#tbtn-cycle{background:rgba(99,102,241,.12);border-color:rgba(99,102,241,.4);color:#a5b4fc}
#tbtn-home{background:rgba(74,222,128,.12);border-color:rgba(74,222,128,.4);color:#4ade80}
.tbtn-icon{font-size:18px;line-height:1}

/* â”€â”€ LOGIN SCREEN â”€â”€ */
#login-screen{position:absolute;inset:0;background:#f7f6f0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;z-index:100}
#login-title{font-family:'Cinzel',serif;font-size:26px;color:#1a1a18;letter-spacing:8px}
#login-sub{font-size:8px;color:#9a9488;letter-spacing:3px}
#login-box{background:#ffffff;border:1px solid #e5e4de;padding:22px 28px;width:300px;display:flex;flex-direction:column;gap:10px;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.08)}
#login-box input{background:#f7f6f0;border:1px solid #d0cfc8;color:#1a1a18;padding:8px 10px;font-family:'Share Tech Mono',monospace;font-size:11px;outline:none;width:100%;box-sizing:border-box;border-radius:4px}
#login-box input:focus{border-color:#d97706;outline:none}
#login-box input::placeholder{color:#c0beb6}
.lbtn{padding:9px;background:#1a1a18;border:none;color:#f7f6f0;font-family:'Share Tech Mono',monospace;font-size:9px;cursor:pointer;letter-spacing:2px;width:100%;border-radius:4px}
.lbtn:hover{background:#333}
.lbtn.primary{background:#f0efe9;color:#6b6860;border:1px solid #d0cfc8}
#login-msg{font-size:8px;text-align:center;min-height:12px;letter-spacing:1px;color:#9a9488}
#login-msg.err{color:#dc2626}
#login-msg.ok{color:#15803d}
#login-switch{font-size:7px;color:#9a9488;text-align:center;cursor:pointer;letter-spacing:1px;margin-top:2px}
#login-switch:hover{color:#d97706}

/* â”€â”€ SAVE SLOTS SCREEN â”€â”€ */
#saves-screen{position:absolute;inset:0;background:#f7f6f0;display:none;flex-direction:column;align-items:center;justify-content:center;gap:20px;z-index:99}
#saves-title{font-family:'Cinzel',serif;font-size:18px;color:#1a1a18;letter-spacing:6px}
#saves-subtitle{font-size:7px;color:#9a9488;letter-spacing:2px}
#saves-list{display:flex;gap:12px}
.sv{width:170px;min-height:155px;border:1px solid #e5e4de;background:#ffffff;padding:14px;display:flex;flex-direction:column;gap:6px;cursor:pointer;position:relative;transition:border-color .15s;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
.sv:hover{border-color:#d97706}
.sv .sv-n{font-size:7px;color:#9a9488;letter-spacing:2px}
.sv .sv-title{font-size:10px;color:#1a1a18;font-family:'Cinzel',serif;margin-top:2px}
.sv .sv-stat{font-size:7px;color:#6b6860;line-height:1.9}
.sv .sv-stat span{color:#1a1a18;font-weight:bold}
.sv .sv-time{font-size:6px;color:#9a9488;margin-top:auto;padding-top:6px;border-top:1px solid #e5e4de}
.sv.empty{align-items:center;justify-content:center;border-style:dashed;background:#f7f6f0}
.sv.empty:hover{border-color:#d97706}
.sv .sv-empty-icon{font-size:26px;color:#d0cfc8;margin-bottom:6px}
.sv .sv-empty-txt{font-size:7px;color:#9a9488;letter-spacing:2px}
.sv .sv-del{position:absolute;top:6px;right:8px;font-size:7px;color:#c0beb6;cursor:pointer;padding:2px 4px;border:1px solid transparent;border-radius:2px}
.sv .sv-del:hover{color:#dc2626;border-color:#dc262644}
#saves-loading{font-size:8px;color:#9a9488;letter-spacing:3px;animation:fadeIn .5s}

/* â”€â”€ USER BAR (top right in homebase) â”€â”€ */
#user-bar{display:none;align-items:center;gap:8px;font-size:7px;color:#6b6860}
#user-email{color:#9a9488;max-width:140px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
#btn-logout{background:none;border:1px solid #d0cfc8;color:#6b6860;font-family:'Share Tech Mono',monospace;font-size:7px;padding:3px 7px;cursor:pointer;letter-spacing:1px;border-radius:3px}
#btn-logout:hover{border-color:#dc2626;color:#dc2626}
#btn-save-now{background:none;border:1px solid #15803d66;color:#15803d;font-family:'Share Tech Mono',monospace;font-size:7px;padding:3px 7px;cursor:pointer;letter-spacing:1px;border-radius:3px}
#btn-save-now:hover{border-color:#15803d;background:#15803d15}
#save-status{font-size:7px;color:#9a9488;min-width:60px;text-align:right}

/* â”€â”€ SIDE PANEL SYSTEM â”€â”€ */
#side-panel{position:absolute;bottom:10px;right:10px;display:flex;flex-direction:row;align-items:flex-end;gap:4px;pointer-events:all}
#side-tabs{display:flex;flex-direction:column;gap:4px}
.side-tab{width:38px;height:38px;background:rgba(10,10,16,0.88);border:1px solid #2e2e42;border-radius:6px;cursor:pointer;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:15px;color:#5a5870;transition:all .15s;padding:2px;line-height:1.1}
.side-tab span{font-size:5px;letter-spacing:0.5px;font-family:'Share Tech Mono',monospace;color:#3a3a52}
.side-tab:hover{border-color:#d97706;color:#d97706}
.side-tab:hover span{color:#d97706}
.side-tab.active{border-color:#d97706;background:rgba(22,18,10,0.96);color:#d97706}
.side-tab.active span{color:#d97706}
.side-content{background:rgba(10,10,16,0.94);border:1px solid #2e2e42;padding:8px;border-radius:6px;box-shadow:0 4px 24px rgba(0,0,0,0.55);width:215px}

/* å¼¹è¯æ§½ */
#raid-ammo-grid{display:grid;grid-template-columns:1fr 1fr;gap:3px}
.ammo-slot{background:#12121e;border:1px solid #22223a;border-radius:4px;padding:3px 5px;display:flex;align-items:center;gap:4px;min-height:28px}
.ammo-slot.filled{border-color:#7c3aed55;background:#160e22}
.ammo-icon{font-size:12px;flex-shrink:0}
.ammo-qty{font-size:8px;color:#a855f7;font-weight:bold;min-width:20px}
.ammo-name{font-size:5px;color:#5a5a78;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
</style>
</head>
<body>
<!-- â”€â”€ Loading Screen â”€â”€ -->
<div id="load-screen" style="
  position:fixed;inset:0;z-index:9999;
  background:#060a10;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  font-family:Consolas,monospace;color:#4a8aba;
">
  <div style="font-size:28px;font-weight:bold;letter-spacing:4px;color:#8ac4e8;margin-bottom:12px">
    âš— ARCANE EXTRACTION
  </div>
  <div id="load-msg" style="font-size:13px;opacity:0.7">åŠ è½½æ¸¸æˆæ•°æ®â€¦</div>
  <div style="margin-top:18px;width:200px;height:3px;background:#0d1a28;border-radius:2px;overflow:hidden">
    <div style="height:100%;background:#4a8aba;animation:ldbar 1.2s ease-in-out infinite alternate;transform-origin:left"></div>
  </div>
  <style>@keyframes ldbar{from{width:20%}to{width:90%}}</style>
</div>
<div id="app">
  <canvas id="three-canvas" width="900" height="600" style="position:absolute;top:0;left:0"></canvas>

  <!-- IN-RAID HUD -->
  <div id="hud">
    <!-- é¡¶æ  -->
    <div id="top-bar">
      <div class="stat-block">
        <div class="bar-label">VITALITY</div>
        <div class="bar-bg" style="width:120px"><div class="bar-fill" id="hp-fill" style="width:100%"></div></div>
      </div>

      <div id="zone-label">FORSAKEN SANCTUM</div>
      <div id="gold-display">â—ˆ 0</div>
    </div>
    <!-- æˆ˜æ–—æ—¥å¿— å·¦ä¸Š -->
    <div id="log"></div>
    <!-- å°åœ°å›¾ å³ä¸Š -->
    <div id="minimap"><canvas id="mm-canvas" width="90" height="90"></canvas></div>
    <div id="elev-badge"></div>
    <!-- æ‹¾å–è¿›åº¦æ¡ åº•éƒ¨ä¸­å¤® -->
    <div id="pickup-bar-wrap">
      <div id="pickup-label">LOOTING...</div>
      <div id="pickup-bg"><div id="pickup-fill"></div></div>
    </div>
    <!-- æ­¦å™¨ä¿¡æ¯ å·¦ä¸‹ -->
    <div id="weapon-hud">
      <div id="weapon-name">BARE HANDS</div>
      <div id="weapon-stats">DMG 5â€“8 Â· RNG 40</div>
      <div id="ammo-hud" style="font-size:8px;color:#a855f7;margin-top:3px"></div>
    </div>

    <!-- ç›¸æœºè°ƒèŠ‚æ»‘æ¡ å·¦ä¸‹è§’ -->
    <div id="cam-controls" style="position:absolute;bottom:10px;left:140px;background:rgba(10,10,16,0.82);border:1px solid #2e2e42;border-radius:5px;padding:6px 10px;pointer-events:all;font-size:7px;color:#5a5870;display:flex;flex-direction:column;gap:4px;min-width:160px">
      <div style="font-size:6px;color:#3a3a52;letter-spacing:2px;margin-bottom:2px">CAMERA</div>
      <div style="display:flex;align-items:center;gap:6px">
        <span style="width:20px">H</span>
        <input id="sl-h" type="range" min="200" max="2000" step="50" value="800" style="flex:1;height:3px;accent-color:#d97706">
        <span id="val-h" style="width:28px;text-align:right">800</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <span style="width:20px">ANG</span>
        <input id="sl-a" type="range" min="10" max="80" step="1" value="45" style="flex:1;height:3px;accent-color:#d97706">
        <span id="val-a" style="width:28px;text-align:right">45</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <span style="width:20px">Z</span>
        <input id="sl-z" type="range" min="100" max="1200" step="20" value="420" style="flex:1;height:3px;accent-color:#d97706">
        <span id="val-z" style="width:28px;text-align:right">420</span>
      </div>
    </div>
    <!-- å³ä¾§ï¼šTabæŒ‰é’® + é¢æ¿ -->
    <div id="side-panel">
      <div id="side-tabs">
        <button class="side-tab" id="tab-equip" onclick="togglePanel('equip')" title="è£…å¤‡">âš”<br><span>è£…å¤‡</span></button>
        <button class="side-tab" id="tab-bag"   onclick="togglePanel('bag')"   title="èƒŒåŒ…">ğŸ’<br><span>èƒŒåŒ…</span></button>
      </div>
      <!-- è£…å¤‡é¢æ¿ -->
      <div id="panel-equip" class="side-content" style="display:none">
        <div class="raid-panel-title">EQUIPMENT</div>
        <div id="raid-equip-grid">
          <div class="req-slot" id="req-weapon" onclick="raidEquipClick('weapon')">
            <span class="req-icon">âš”</span><div class="req-info"><span class="req-label">WEAPON</span><span class="req-name">â€” empty â€”</span></div>
          </div>
          <div class="req-slot" id="req-armor" onclick="raidEquipClick('armor')">
            <span class="req-icon">ğŸ›¡</span><div class="req-info"><span class="req-label">ARMOR</span><span class="req-name">â€” empty â€”</span></div>
          </div>
          <div class="req-slot" id="req-boots" onclick="raidEquipClick('boots')">
            <span class="req-icon">ğŸ‘¢</span><div class="req-info"><span class="req-label">BOOTS</span><span class="req-name">â€” empty â€”</span></div>
          </div>
          <div class="req-slot" id="req-acc" onclick="raidEquipClick('acc')">
            <span class="req-icon">ğŸ’</span><div class="req-info"><span class="req-label">ACC</span><span class="req-name">â€” empty â€”</span></div>
          </div>
        </div>
        <div class="raid-panel-title" style="margin-top:8px">AMMO</div>
        <div id="raid-ammo-grid"></div>
      </div>
      <!-- èƒŒåŒ…é¢æ¿ -->
      <div id="panel-bag" class="side-content" style="display:none">
        <div class="raid-panel-title">BACKPACK <span id="inv-weight" style="color:#5a5870;font-size:6px"></span></div>
        <div id="inv-grid"></div>
        <div id="inv-actions">
          <button class="inv-btn" id="btn-equip" disabled onclick="equipSelected()">EQUIP</button>
          <button class="inv-btn" id="btn-sell-inv" disabled onclick="sellFromInventory()" style="color:#4ade80">SELL</button>
          <button class="inv-btn" id="btn-drop" disabled onclick="dropSelected()">DROP</button>
        </div>
      </div>
      <!-- æˆ˜åˆ©å“é¢æ¿ æ‹¾å–åè‡ªåŠ¨å¼¹å‡º -->
      <div id="raid-loot" class="side-content" style="display:none">
        <div class="raid-panel-title">LOOT â€” <span id="loot-source-name" style="color:#fbbf24"></span></div>
        <div id="loot-grid"></div>
        <div id="loot-actions">
          <button class="inv-btn" id="btn-loot-take" disabled onclick="lootSelected()">TAKE</button>
          <button class="inv-btn" onclick="lootAll()">ALL</button>
          <button class="inv-btn" onclick="closeLootPanel()" style="color:#f87171">âœ• CLOSE</button>
        </div>
      </div>
    </div>
  </div>

  <!-- PICKUP PROGRESS (canvas overlay) -->

  <!-- DEATH / EXTRACT OVERLAYS -->
  <div class="overlay-screen" id="death-screen">
    <h1>SLAIN</h1>
    <p id="death-msg"></p>
    <button onclick="goHomebase()">RETURN TO BASE</button>
  </div>
  <div class="overlay-screen" id="extract-screen">
    <h1>EXTRACTED</h1>
    <div class="summary" id="extract-summary"></div>
    <button onclick="goHomebase()">RETURN TO BASE</button>
  </div>

  <!-- HOMEBASE -->
  <div id="homebase">
    <div id="hb-header">
      <div id="hb-title">HOME BASE</div>
      <div id="hb-gold">â—ˆ <span id="hb-gold-val">0</span></div>
      <div id="user-bar">
        <div id="user-email"></div>
        <button id="btn-save-now" onclick="saveGame()">ğŸ’¾ SAVE</button>
        <div id="save-status"></div>
        <button id="btn-logout" onclick="doLogout()">LOGOUT</button>
      </div>
      <button id="hb-btn-raid" onclick="startRaid()">â–¶ RAID</button>
    </div>
    <div id="hb-body">
      <!-- LEFT: Stash -->
      <div id="hb-storage">
        <div class="hb-section-title">STASH <span id="loadout-hint" style="color:#fbbf24;font-size:7px;margin-left:8px"></span></div>
        <div id="storage-grid"></div>
      </div>
      <!-- CENTER: Loadout (equipment slots + bag) -->
      <div id="hb-loadout">
        <div class="hb-section-title">LOADOUT Â· å‡ºå‡»é…ç½®</div>
        <!-- Equipment slots row -->
        <div id="equip-slots-row">
          <div class="equip-slot-wrap">
            <div class="equip-slot-label">æ­¦å™¨</div>
            <div class="equip-slot" id="eslot-weapon" data-type="wand" onclick="clickEquipSlot('weapon')">
              <span class="eslot-empty">âš”</span>
            </div>
          </div>
          <div class="equip-slot-wrap">
            <div class="equip-slot-label">é˜²å…·</div>
            <div class="equip-slot" id="eslot-armor" data-type="armor" onclick="clickEquipSlot('armor')">
              <span class="eslot-empty">ğŸ›¡</span>
            </div>
          </div>
          <div class="equip-slot-wrap">
            <div class="equip-slot-label">é‹å­</div>
            <div class="equip-slot" id="eslot-boots" data-type="boots" onclick="clickEquipSlot('boots')">
              <span class="eslot-empty">ğŸ‘¢</span>
            </div>
          </div>
          <div class="equip-slot-wrap">
            <div class="equip-slot-label">é¥°å“</div>
            <div class="equip-slot" id="eslot-acc" data-type="acc" onclick="clickEquipSlot('acc')">
              <span class="eslot-empty">ğŸ’</span>
            </div>
          </div>
        </div>
        <!-- Ammo slots -->
        <div class="hb-section-title" style="margin-top:10px">çµæ™¶ Â· å¼¹è¯</div>
        <div id="ammo-slots-row">
          <div class="ammo-slot" id="aslot-0" onclick="clickAmmoSlot(0)"><span class="aslot-empty">+</span></div>
          <div class="ammo-slot" id="aslot-1" onclick="clickAmmoSlot(1)"><span class="aslot-empty">+</span></div>
          <div class="ammo-slot" id="aslot-2" onclick="clickAmmoSlot(2)"><span class="aslot-empty">+</span></div>
          <div class="ammo-slot" id="aslot-3" onclick="clickAmmoSlot(3)"><span class="aslot-empty">+</span></div>
        </div>
        <div style="font-size:6px;color:#2a2a3a;margin-top:4px">ç‚¹ä»“åº“ç‰©å“ â†’ ç‚¹æ§½ä½æ”¾å…¥ Â· ç‚¹å·²å æ§½ä½é€€å›</div>
        <!-- Bag loadout -->
        <div class="hb-section-title" style="margin-top:10px">èƒŒåŒ…å¸¦å…¥ (æœ€å¤š4æ ¼)</div>
        <div id="loadout-grid"></div>
        <div style="font-size:6px;color:#2a2a3a;margin-top:4px">ç‚¹å‡»å·²æ”¾å…¥ç‰©å“å¯é€€å›ä»“åº“</div>
      </div>
      <!-- RIGHT: Market -->
      <div id="hb-market">
        <div class="hb-section-title">ARCANE MARKET</div>
        <div id="market-list"></div>
      </div>
    </div>
  </div>


  <!-- LOGIN SCREEN -->
  <div id="login-screen">
    <div id="login-title">ARCANE EXTRACTION</div>
    <div id="login-sub">FORSAKEN SANCTUM Â· EARLY ACCESS</div>
    <div id="login-box">
      <input type="email" id="login-email" placeholder="EMAIL ADDRESS" autocomplete="email"/>
      <input type="password" id="login-pass" placeholder="PASSWORD" autocomplete="current-password"/>
      <button class="lbtn primary" onclick="doLogin()">â–¶ LOGIN</button>
      <button class="lbtn" onclick="doSignup()">+ CREATE ACCOUNT</button>
      <div id="login-msg"></div>
      <div id="login-switch" onclick="toggleLoginMode()">æ²¡æœ‰è´¦å·ï¼Ÿç‚¹æ­¤æ³¨å†Œ</div>
    </div>
  </div>

  <!-- SAVE SLOTS SCREEN -->
  <div id="saves-screen">
    <div id="saves-title">SELECT SAVE</div>
    <div id="saves-subtitle">é€‰æ‹©å­˜æ¡£ä½ç½®</div>
    <div id="saves-list"><div id="saves-loading">LOADING...</div></div>
  </div>
  <!-- TOUCH -->
  <div id="touch-zone">
    <div id="joystick-base"><div id="joystick-knob"></div></div>
    <div id="touch-btns">
      <div class="tbtn" id="tbtn-pickup" ontouchstart="startPickupTouch(event)"><div class="tbtn-icon">â—†</div>æ‹¾å–</div>
      <div class="tbtn" id="tbtn-cycle" ontouchstart="cycleWeapon()"><div class="tbtn-icon">âš¡</div>åˆ‡æ¢</div>
      <div class="tbtn" id="tbtn-home" ontouchstart="goHomebase()"><div class="tbtn-icon">âŒ‚</div>æ’¤ç¦»</div>
    </div>
  </div>
</div>

<script>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SUPABASE CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SUPA_URL='https://vvhoznnsywkfxbijzwvk.supabase.co';
const SUPA_KEY='sb_publishable_7opFB4gcVM8Vw0V7ASmGKA_dpBgLaJx';
const sb=supabase.createClient(SUPA_URL,SUPA_KEY);

let currentUser=null;
let currentSlot=null;
let saveTimer=null;
let loginMode='login'; // 'login' | 'signup'
// â”€â”€ AUTH â”€â”€
function toggleLoginMode(){
  loginMode=loginMode==='login'?'signup':'login';
  document.getElementById('login-switch').textContent=
    loginMode==='login'?'æ²¡æœ‰è´¦å·ï¼Ÿç‚¹æ­¤æ³¨å†Œ':'å·²æœ‰è´¦å·ï¼Ÿç‚¹æ­¤ç™»å½•';
  setLoginMsg('');
}

function setLoginMsg(msg,type=''){
  const el=document.getElementById('login-msg');
  el.textContent=msg;
  el.className=type;
}

async function doLogin(){
  const email=document.getElementById('login-email').value.trim();
  const pass=document.getElementById('login-pass').value;
  if(!email||!pass){setLoginMsg('è¯·å¡«å†™é‚®ç®±å’Œå¯†ç ','err');return;}
  setLoginMsg('ç™»å½•ä¸­...','');
  const {data,error}=await sb.auth.signInWithPassword({email,password:pass});
  if(error){setLoginMsg(error.message==='Invalid login credentials'?'é‚®ç®±æˆ–å¯†ç é”™è¯¯':error.message,'err');return;}
  currentUser=data.user;
  onLoggedIn();
}

async function doSignup(){
  const email=document.getElementById('login-email').value.trim();
  const pass=document.getElementById('login-pass').value;
  if(!email||!pass){setLoginMsg('è¯·å¡«å†™é‚®ç®±å’Œå¯†ç ','err');return;}
  if(pass.length<6){setLoginMsg('å¯†ç è‡³å°‘6ä½','err');return;}
  setLoginMsg('æ³¨å†Œä¸­...','');
  const {data,error}=await sb.auth.signUp({email,password:pass});
  if(error){setLoginMsg(error.message,'err');return;}
  if(data.user&&!data.session){
    setLoginMsg('æ³¨å†ŒæˆåŠŸï¼è¯·æ£€æŸ¥é‚®ç®±éªŒè¯é“¾æ¥','ok');return;
  }
  currentUser=data.user;
  onLoggedIn();
}

async function doLogout(){
  await sb.auth.signOut();
  currentUser=null;currentSlot=null;
  gold=CONFIG.PLAYER_START_GOLD||1000;stash=[];loadout=[];
  equipSlots={weapon:null,armor:null,boots:null,acc:null};
  ammoSlots=[null,null,null,null];
  bagLoadout=[];
  document.getElementById('homebase').style.display='none';
  document.getElementById('login-screen').style.display='flex';
  document.getElementById('user-bar').style.display='none';
  setLoginMsg('å·²é€€å‡ºç™»å½•','ok');
}

function onLoggedIn(){
  document.getElementById('login-screen').style.display='none';
  document.getElementById('user-email').textContent=currentUser.email;
  document.getElementById('user-bar').style.display='flex';
  showSaves();
}

// â”€â”€ SAVE SLOTS â”€â”€
async function showSaves(){
  const screen=document.getElementById('saves-screen');
  screen.style.display='flex';
  document.getElementById('saves-list').innerHTML='<div id="saves-loading">LOADING...</div>';

  const {data,error}=await sb.from('saves').select('*').eq('user_id',currentUser.id).order('slot');
  const slotMap={};
  if(data) data.forEach(s=>slotMap[s.slot]=s);

  const list=document.getElementById('saves-list');
  list.innerHTML='';
  for(let i=1;i<=3;i++){
    const s=slotMap[i];
    const div=document.createElement('div');
    if(s){
      const d=new Date(s.updated_at);
      const timeStr=d.toLocaleDateString('zh-CN')+' '+d.toLocaleTimeString('zh-CN',{hour:'2-digit',minute:'2-digit'});
      div.className='sv';
      div.innerHTML=`
        <div class="sv-n">SLOT ${i}</div>
        <div class="sv-title">ARCANE HUNTER</div>
        <div class="sv-stat">
          â—ˆ é‡‘å¸ <span>${s.gold||0}</span><br>
          ğŸ“¦ ä»“åº“ <span>${(s.stash||[]).length} ä»¶</span><br>
          âš”ï¸ å‡ºå‡» <span>${s.raids||0} æ¬¡</span>
        </div>
        <div class="sv-time">${timeStr}</div>
        <div class="sv-del" onclick="deleteSave(event,${i})">âœ•</div>
      `;
      div.onclick=()=>loadSave(s);
    } else {
      div.className='sv empty';
      div.innerHTML=`<div class="sv-empty-icon">+</div><div class="sv-empty-txt">NEW GAME</div>`;
      div.onclick=()=>newGame(i);
    }
    list.appendChild(div);
  }
}

async function deleteSave(e,slot){
  e.stopPropagation();
  if(!confirm(`ç¡®è®¤åˆ é™¤å­˜æ¡£ ${slot}ï¼Ÿ`))return;
  await sb.from('saves').delete().eq('user_id',currentUser.id).eq('slot',slot);
  showSaves();
}

function newGame(slot){
  currentSlot=slot;
  gold=CONFIG.PLAYER_START_GOLD||1000;stash=[];loadout=[];
  equipSlots={weapon:null,armor:null,boots:null,acc:null};
  ammoSlots=[null,null,null,null];
  bagLoadout=[];
  document.getElementById('saves-screen').style.display='none';
  refreshMarket();
  renderHomebase();
  document.getElementById('homebase').style.display='flex';
  setSaveStatus('æ–°æ¡£ä½');
  autoSave();
}

function loadSave(s){
  currentSlot=s.slot;
  gold=s.gold||200;
  stash=(s.stash||[]).map(item=>({...item}));
  try{
    const ld=typeof s.loadout==='string'?JSON.parse(s.loadout):s.loadout||{};
    equipSlots=ld.equipSlots||{weapon:null,armor:null,boots:null,acc:null};
    ammoSlots=(ld.ammoSlots||[null,null,null,null]).map(a=>a||null);
    bagLoadout=(ld.bagLoadout||[]).map(i=>i||null);
  }catch(e){
    equipSlots={weapon:null,armor:null,boots:null,acc:null};
    ammoSlots=[null,null,null,null];
    bagLoadout=[];
  }
  loadout=[];
  document.getElementById('saves-screen').style.display='none';
  refreshMarket();
  renderHomebase();
  document.getElementById('homebase').style.display='flex';
  setSaveStatus('å·²è½½å…¥');
}

// â”€â”€ SAVE GAME â”€â”€
async function saveGame(){
  if(!currentUser||!currentSlot)return;
  setSaveStatus('ä¿å­˜ä¸­...');
  const payload={
    user_id:currentUser.id,
    slot:currentSlot,
    gold,
    stash:stash.map(i=>({...i})),
    loadout:JSON.stringify({
      equipSlots,
      ammoSlots,
      bagLoadout,
    }),
    raids:(await getRaids())+0,
    updated_at:new Date().toISOString(),
  };
  const {error}=await sb.from('saves').upsert(payload,{onConflict:'user_id,slot'});
  if(error){setSaveStatus('ä¿å­˜å¤±è´¥','err');}
  else{setSaveStatus('å·²ä¿å­˜ âœ“');}
}

async function getRaids(){
  const {data}=await sb.from('saves').select('raids').eq('user_id',currentUser.id).eq('slot',currentSlot).single();
  return data?.raids||0;
}

function setSaveStatus(msg){
  const el=document.getElementById('save-status');
  el.textContent=msg;
  clearTimeout(saveTimer);
  if(msg!=='ä¿å­˜ä¸­...')saveTimer=setTimeout(()=>{el.textContent='';},3000);
}

// Auto-save every 60s when on homebase
function autoSave(){
  setInterval(()=>{
    if(gameState==='homebase'&&currentUser&&currentSlot) saveGame();
  },60000);
}

// Save on extract
const _origGoHomebase=typeof goHomebase!=='undefined'?goHomebase:null;

// â”€â”€ INIT: check existing session â”€â”€
async function initAuth(){
  const {data}=await sb.auth.getSession();
  if(data.session){
    currentUser=data.session.user;
    document.getElementById('user-email').textContent=currentUser.email;
    document.getElementById('user-bar').style.display='flex';
    document.getElementById('login-screen').style.display='none';
    showSaves();
  }
  // else login screen stays visible (default)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS & CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const W=900,H=600,MAP_W=2000,MAP_H=1600,TILE=40;

// â”€â”€ GAME BALANCE CONFIG â”€â”€ (loaded from gamedata.json, defaults below)
let CONFIG={
  ENEMY_INITIAL: 14,
  ENEMY_MAX: 8,
  ENEMY_RESPAWN: 2,
  CHEST_COUNT: 20,
  PLAYER_HP: 100,
  PLAYER_SPD: 2.9,
  PLAYER_START_GOLD: 1000,
  PICKUP_RANGE: 46,
  CHEST_B_COUNT: 10,
  CHEST_A_COUNT: 8,
  CHEST_S_COUNT: 5,
  MARKET_PRICE_VARIANCE: 0.4,
};
const COLS=Math.ceil(MAP_W/TILE),ROWS=Math.ceil(MAP_H/TILE);
const PICKUP_TIME=1.8;
const JOYSTICK_MAX=40;
// PICKUP_RANGE ä» CONFIG è¯»ï¼ˆapplyGameData åä¼šæ›´æ–°ï¼‰ï¼Œå…ˆç»™é»˜è®¤å€¼
let PICKUP_RANGE=46;

const ELEV_NAMES=['LOW GROUND','MID GROUND','HIGH GROUND'];
const ELEV_COLORS=['#4a3a2a','#4a4a2a','#2a4a5a'];

// â”€â”€ æ•°æ®è¡¨ï¼ˆä» gamedata.json å¡«å……ï¼Œå…ˆå£°æ˜ä¸ºç©ºï¼‰â”€â”€
let WANDS=[], ARMORS=[], CRYSTALS=[], ENEMY_TYPES=[];
let ELEMENTS=['fire','ice','thunder','void'];
const ELEM_ICONS={'fire':'ğŸ”´','ice':'ğŸ”µ','thunder':'ğŸŸ¡','void':'ğŸŸ£'};
const ELEM_COLORS={'fire':'#f97316','ice':'#67e8f9','thunder':'#fbbf24','void':'#a855f7'};
let WAND_ELEM={};
let ALL_ITEMS=[];

function getCrystal(elem,tier){return CRYSTALS.find(c=>c.elem===elem&&c.tier===tier);}

// Market prices fluctuate each visit
let marketPrices={};
function refreshMarket(){
  const marketItems=ALL_ITEMS.filter(w=>w.type!=='crystal'||w.tier<=2);
  marketItems.forEach(w=>{
    const factor=0.8+Math.random()*(CONFIG.MARKET_PRICE_VARIANCE||0.4);
    marketPrices[w.id]=Math.round(w.basePrice*factor);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAMEDATA LOADER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function applyGameData(gd){
  // CONFIG
  if(gd.config) Object.assign(CONFIG, gd.config);
  if(CONFIG.PICKUP_RANGE) PICKUP_RANGE = CONFIG.PICKUP_RANGE;

  // WANDS
  WANDS = gd.wands || [];

  // ARMORSï¼ˆåŒ…å« boots å’Œ accï¼‰
  ARMORS = gd.armors || [];

  // CRYSTALS
  CRYSTALS = gd.crystals || [];

  // ENEMY_TYPESï¼šæŠŠ JSON çš„æ‰è½å­—æ®µè½¬æˆæ¸¸æˆå†…æ ¼å¼
  ENEMY_TYPES = (gd.enemies || []).map(e=>({
    id:            e.id,
    name:          e.name,
    hp:            e.hp,
    spd:           e.spd,
    dmg:           e.dmg,
    color:         e.color,
    r:             e.r,
    xp:            e.xp,
    aggroRange:    e.aggroRange || 200,
    attackRate:    e.attackRate || 1.0,
    ranged:        !!e.ranged,
    range:         e.range || 60,
    elev:          0,
    // æ‰è½é…ç½®
    _dropWandIds:      e.drop_wand_ids || [],
    _dropArmorIds:     e.drop_armor_ids || [],
    _dropCrystalTiers: e.drop_crystal_tiers || [1,2],
    _dropWandChance:   e.drop_wand_chance ?? 0.25,
    _dropArmorChance:  e.drop_armor_chance ?? 0.20,
    _dropCrystalMin:   e.drop_crystal_min ?? 2,
  }));

  // WAND_ELEM
  WAND_ELEM = gd.wand_elem_map || {};

  // ALL_ITEMS åˆå¹¶
  ALL_ITEMS = [...WANDS, ...ARMORS, ...CRYSTALS];

  console.log(`[gamedata] wands:${WANDS.length} armors:${ARMORS.length} crystals:${CRYSTALS.length} enemies:${ENEMY_TYPES.length}`);
}

async function loadGameData(){
  const loadScreen = document.getElementById('load-screen');
  const loadMsg    = document.getElementById('load-msg');
  if(loadMsg) loadMsg.textContent = 'åŠ è½½æ¸¸æˆæ•°æ®â€¦';
  try {
    const res = await fetch('gamedata.json');
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const gd = await res.json();
    applyGameData(gd);
    if(loadMsg) loadMsg.textContent = 'åˆå§‹åŒ–åœºæ™¯â€¦';
  } catch(err){
    console.warn('[gamedata] åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®é»˜è®¤æ•°æ®:', err.message);
    applyGameData(BUILTIN_GAMEDATA);
    if(loadMsg) loadMsg.textContent = 'ä½¿ç”¨å†…ç½®æ•°æ®ï¼ˆç¦»çº¿æ¨¡å¼ï¼‰â€¦';
  }
  // çŸ­æš‚åœç•™åéšè— loading ç•Œé¢
  setTimeout(()=>{
    if(loadScreen) loadScreen.style.display='none';
    initGame();
  }, 400);
}

// â”€â”€ å†…ç½®å…œåº•æ•°æ®ï¼ˆgamedata.json ä¸å¯ç”¨æ—¶ä½¿ç”¨ï¼‰â”€â”€
const BUILTIN_GAMEDATA = {
  config: {ENEMY_INITIAL:14,ENEMY_MAX:8,ENEMY_RESPAWN:2,PLAYER_HP:100,PLAYER_SPD:2.9,PLAYER_START_GOLD:1000,PICKUP_RANGE:46,CHEST_B_COUNT:10,CHEST_A_COUNT:8,CHEST_S_COUNT:5,MARKET_PRICE_VARIANCE:0.4},
  wands:[
    {id:'ember',   name:'EMBER WAND',  icon:'ğŸ”¥',dmg:[12,18],range:160,spd:1.5,color:'#f97316',proj:'#fb923c',desc:'ç«ç„°Â·ä¸­è·',   size:[1,3],basePrice:120,aoe:0},
    {id:'frost',   name:'FROST STAFF', icon:'â„ï¸', dmg:[8,14], range:240,spd:0.9,color:'#67e8f9',proj:'#a5f3fc',desc:'å†°éœœÂ·è¿œè·Â·å‡é€Ÿ',size:[1,3],basePrice:150,slow:true,aoe:0},
    {id:'thunder', name:'THUNDER ROD', icon:'âš¡', dmg:[22,34],range:130,spd:0.55,color:'#fbbf24',proj:'#fde68a',desc:'é›·å‡»Â·é«˜ä¼¤',  size:[1,3],basePrice:200,aoe:0},
    {id:'void',    name:'VOID SCEPTER',icon:'ğŸŒ€',dmg:[15,22],range:190,spd:1.1,color:'#a855f7',proj:'#c084fc',desc:'è™šç©ºÂ·AOEç©¿é€',size:[1,3],basePrice:180,aoe:32,pierce:true},
    {id:'nature',  name:'NATURE WAND', icon:'ğŸŒ¿',dmg:[10,16],range:200,spd:1.3,color:'#4ade80',proj:'#86efac',desc:'è‡ªç„¶Â·å¸è¡€',  size:[1,3],basePrice:160,vamp:true,aoe:0},
    {id:'ancient', name:'ANCIENT TOME',icon:'ğŸ“œ',dmg:[28,44],range:260,spd:0.45,color:'#fcd34d',proj:'#fef08a',desc:'è¿œå¤Â·è¶…é«˜ä¼¤',size:[1,3],basePrice:300,aoe:0},
    {id:'poison',  name:'POISON ORB',  icon:'ğŸ’€',dmg:[6,10], range:170,spd:1.6,color:'#84cc16',proj:'#bef264',desc:'æ¯’Â·æŒç»­ä¼¤å®³', size:[1,2],basePrice:100,dot:true,aoe:0},
    {id:'blood',   name:'BLOOD LANCE', icon:'ğŸ©¸',dmg:[18,28],range:150,spd:0.8,color:'#dc2626',proj:'#f87171',desc:'è¡€çŸ›Â·é«˜ç©¿é€', size:[1,3],basePrice:220,pierce:true,aoe:0},
  ],
  armors:[
    {id:'robe1',name:'TATTERED ROBE',  icon:'ğŸ‘˜',type:'armor',tier:1,def:3, color:'#78716c',size:[1,2],basePrice:60, desc:'é˜²å¾¡+3'},
    {id:'robe2',name:'WOVEN MANTLE',   icon:'ğŸ¥»',type:'armor',tier:2,def:7, color:'#a16207',size:[1,2],basePrice:130,desc:'é˜²å¾¡+7'},
    {id:'robe3',name:'ARCANE VESTMENT',icon:'ğŸ©±',type:'armor',tier:3,def:13,color:'#6366f1',size:[1,2],basePrice:240,desc:'é˜²å¾¡+13'},
    {id:'robe4',name:'VOID SHROUD',    icon:'ğŸ¦º',type:'armor',tier:4,def:22,color:'#a855f7',size:[1,2],basePrice:400,desc:'é˜²å¾¡+22'},
    {id:'boot1',name:'WORN SANDALS',   icon:'ğŸ‘¡',type:'boots',tier:1,spd:0.3,color:'#78716c',size:[1,2],basePrice:50, desc:'é€Ÿåº¦+0.3'},
    {id:'boot2',name:'LEATHER BOOTS',  icon:'ğŸ‘¢',type:'boots',tier:2,spd:0.6,color:'#92400e',size:[1,2],basePrice:110,desc:'é€Ÿåº¦+0.6'},
    {id:'boot3',name:'SWIFT TREADS',   icon:'ğŸ¥¾',type:'boots',tier:3,spd:1.0,color:'#0891b2',size:[1,2],basePrice:200,desc:'é€Ÿåº¦+1.0'},
    {id:'boot4',name:'PHANTOM STEPS',  icon:'ğŸ‘Ÿ',type:'boots',tier:4,spd:1.6,color:'#7c3aed',size:[1,2],basePrice:350,desc:'é€Ÿåº¦+1.6'},
    {id:'acc1', name:'COPPER RING',    icon:'ğŸ’',type:'acc',  tier:1,maxHp:15,color:'#78716c',size:[1,1],basePrice:80, desc:'ç”Ÿå‘½+15'},
    {id:'acc2', name:'SILVER AMULET',  icon:'ğŸ“¿',type:'acc',  tier:2,maxHp:30,color:'#94a3b8',size:[1,1],basePrice:160,desc:'ç”Ÿå‘½+30'},
    {id:'acc3', name:'GOLD PENDANT',   icon:'ğŸ…',type:'acc',  tier:3,maxHp:50,xpBonus:0.2,color:'#f59e0b',size:[1,1],basePrice:280,desc:'ç”Ÿå‘½+50Â·ç»éªŒ+20%'},
    {id:'acc4', name:'SOUL CRYSTAL',   icon:'ğŸ’',type:'acc',  tier:4,maxHp:80,xpBonus:0.4,color:'#22d3ee',size:[1,1],basePrice:500,desc:'ç”Ÿå‘½+80Â·ç»éªŒ+40%'},
  ],
  crystals: (()=>{
    const elems=['fire','ice','thunder','void'];
    const tiers=[{t:1,n:'ç²—ç³™çµæ™¶',m:1.0,p:15},{t:2,n:'ç²¾åˆ¶çµæ™¶',m:1.4,p:35},{t:3,n:'çº¯åŒ–çµæ™¶',m:2.0,p:70},{t:4,n:'è‡³çº¯çµæ™¶',m:3.5,p:150}];
    const icons={'fire':'ğŸ”´','ice':'ğŸ”µ','thunder':'ğŸŸ¡','void':'ğŸŸ£'};
    const colors={'fire':'#f97316','ice':'#67e8f9','thunder':'#fbbf24','void':'#a855f7'};
    const cn={'fire':'ç‚','ice':'å†°','thunder':'é›·','void':'è™šç©º'};
    const out=[];
    elems.forEach(el=>tiers.forEach(ti=>out.push({
      id:`crystal_${el}_${ti.t}`,name:`${ti.n}Â·${cn[el]}`,icon:icons[el],
      type:'crystal',elem:el,tier:ti.t,dmgMult:ti.m,color:colors[el],
      size:[1,1],stackMax:99,basePrice:ti.p,desc:`ä¼¤å®³Ã—${ti.m}`,
    })));
    return out;
  })(),
  enemies:[
    {id:'shade',  name:'SHADE',  hp:65, spd:1.3, dmg:9, color:'#6366f1',r:12,xp:20, aggroRange:200,attackRate:1.1,ranged:false,range:60, drop_wand_ids:[],drop_armor_ids:[],drop_crystal_tiers:[1,2],  drop_wand_chance:0.20,drop_armor_chance:0.15,drop_crystal_min:2},
    {id:'wraith', name:'WRAITH', hp:130,spd:0.9, dmg:15,color:'#a855f7',r:16,xp:40, aggroRange:220,attackRate:1.0,ranged:false,range:60, drop_wand_ids:[],drop_armor_ids:[],drop_crystal_tiers:[1,2,3],drop_wand_chance:0.25,drop_armor_chance:0.20,drop_crystal_min:2},
    {id:'golem',  name:'GOLEM',  hp:320,spd:0.45,dmg:28,color:'#78716c',r:22,xp:100,aggroRange:180,attackRate:0.7,ranged:false,range:60, drop_wand_ids:[],drop_armor_ids:['robe3','robe4'],drop_crystal_tiers:[2,3],drop_wand_chance:0.30,drop_armor_chance:0.40,drop_crystal_min:3},
    {id:'specter',name:'SPECTER',hp:50, spd:2.3, dmg:6, color:'#22d3ee',r:9, xp:15, aggroRange:240,attackRate:1.3,ranged:false,range:60, drop_wand_ids:[],drop_armor_ids:[],drop_crystal_tiers:[1],    drop_wand_chance:0.10,drop_armor_chance:0.10,drop_crystal_min:1},
    {id:'cultist',name:'CULTIST',hp:95, spd:1.0, dmg:19,color:'#dc2626',r:14,xp:35, aggroRange:210,attackRate:1.0,ranged:false,range:60, drop_wand_ids:['poison'],drop_armor_ids:['robe2'],drop_crystal_tiers:[1,2],drop_wand_chance:0.35,drop_armor_chance:0.25,drop_crystal_min:2},
    {id:'archer', name:'ARCHER', hp:70, spd:0.8, dmg:14,color:'#f59e0b',r:11,xp:30, aggroRange:300,attackRate:0.9,ranged:true, range:200,drop_wand_ids:['frost'],drop_armor_ids:['boot2'],drop_crystal_tiers:[1,2],drop_wand_chance:0.40,drop_armor_chance:0.20,drop_crystal_min:2},
  ],
  wand_elem_map:{ember:'fire',frost:'ice',thunder:'thunder',void:'void',nature:'void',ancient:'fire',poison:'void',blood:'fire'},
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gold=0; // set from CONFIG in initGame
let stash=[];            // all items in homebase stash
// New loadout structure
let equipSlots={weapon:null,armor:null,boots:null,acc:null}; // equipped items
let ammoSlots=[null,null,null,null];   // crystal stacks {crystal,qty}
let bagLoadout=[];       // extra items carried in bag (max 4)
let selectedStorage=null;
let selectedEquipSlot=null;  // 'weapon'|'armor'|'boots'|'acc'
let selectedAmmoSlot=null;   // 0-3
let selectedLoadout=null;    // bag slot index
// Legacy compat
let loadout=[];

// In-raid
let gameState='homebase'; // homebase | playing | dead | extracted
let frames=0,lastTime=0;
let tileMap=[],elevMap=[];
let enemies=[],chests=[],droppedWands=[],projectiles=[],particles=[];
let player={};
let cam={x:0, y:0}; // è§†å£å·¦ä¸Šè§’ä¸–ç•Œåæ ‡
let pickupTarget=null,pickupProgress=0,pickupHolding=false;
let selectedInvIdx=null;
// Touch
const isTouchDevice=()=>navigator.maxTouchPoints>0;
let joystickDelta={x:0,y:0},joystickActive=false,joystickOrigin={x:0,y:0};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAP GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â”€â”€ Smooth noise helpers â”€â”€
function smoothNoise(x,y,seed){
  // Simple smooth value noise with bilinear interpolation
  const ix=Math.floor(x),iy=Math.floor(y);
  const fx=x-ix,fy=y-iy;
  const u=fx*fx*(3-2*fx),v=fy*fy*(3-2*fy);
  function h(a,b){
    let n=((a*1619+b*31337+seed*6971)^(a*1619+b*31337+seed*6971)>>8)*0.00000023283;
    return Math.sin(n*127.1+n*311.7)*43758.5453%1;
  }
  return h(ix,iy)*(1-u)*(1-v)+h(ix+1,iy)*u*(1-v)+h(ix,iy+1)*(1-u)*v+h(ix+1,iy+1)*u*v;
}
function fbm(x,y,seed,oct=4){
  let v=0,amp=0.5,freq=1,max=0;
  for(let i=0;i<oct;i++){v+=smoothNoise(x*freq,y*freq,seed+i*100)*amp;max+=amp;amp*=0.5;freq*=2;}
  return v/max;
}

let heightMap=[];  // elevation smoothed 0..1 per tile (for rendering ramps)

// â”€â”€ CITY MAP LAYOUT â”€â”€
// Tile types stored in tileMap: 0=floor, 1=solid wall/building
// elevMap: 0=ground, 1=raised platform, 2=rooftop
// slopeMap: direction of ramp if tile is a transition  (null or 'n','s','e','w')
let slopeMap=[];

function fillRect(r0,c0,r1,c1,wall,elv){
  for(let r=r0;r<r1;r++)for(let c=c0;c<c1;c++){
    if(r<0||r>=ROWS||c<0||c>=COLS)continue;
    tileMap[r][c]=wall;
    elevMap[r][c]=elv;
  }
}

function genMap(){
  tileMap=[];elevMap=[];heightMap=[];slopeMap=[];

  for(let r=0;r<ROWS;r++){
    tileMap[r]=[];elevMap[r]=[];heightMap[r]=[];slopeMap[r]=[];
    for(let c=0;c<COLS;c++){
      tileMap[r][c]=0; elevMap[r][c]=0; heightMap[r][c]=0; slopeMap[r][c]=null;
    }
  }

  // è¾¹ç•Œå¢™
  for(let r=0;r<ROWS;r++){ tileMap[r][0]=1; tileMap[r][COLS-1]=1; }
  for(let c=0;c<COLS;c++){ tileMap[0][c]=1; tileMap[ROWS-1][c]=1; }

  // â”€â”€ æå‰å†™å…¥å¹³å°åŒºåŸŸåˆ° elevMapï¼ˆä¾› buildMap3 tile å¾ªç¯è·³è¿‡ï¼‰â”€â”€
  {
    const PX = MAP_W * 0.35, PZ = MAP_H * 0.38;
    const PW = TILE * 8,     PD = TILE * 6;
    const RW = TILE * 2;  // æ–œå¡æ ¼æ•°ï¼ˆtile å¾ªç¯åªéœ€è·³è¿‡å¹³å°æ ¸å¿ƒï¼‰
    const c0=Math.floor((PX-PW/2)/TILE), c1=Math.ceil((PX+PW/2)/TILE);
    const r0=Math.floor((PZ-PD/2)/TILE), r1=Math.ceil((PZ+PD/2)/TILE);
    // å¹³å°æ ¸å¿ƒåŒºï¼šelevMap=2ï¼ˆç”¨2åŒºåˆ†"ç‹¬ç«‹å¹³å°"ï¼Œtileå¾ªç¯è·³è¿‡ï¼‰
    for(let r=r0;r<r1;r++) for(let c=c0;c<c1;c++){
      if(r>=0&&r<ROWS&&c>=0&&c<COLS) elevMap[r][c]=2;
    }
    // æ–œå¡åŒºï¼šelevMap=3ï¼ˆtileå¾ªç¯ä¹Ÿè·³è¿‡ï¼Œç”±3Dç‰©ä»¶è‡ªå·±æ¸²æŸ“åœ°é¢ï¼‰
    for(let r=r0-2;r<r1+2;r++) for(let c=c0-2;c<c1+2;c++){
      if(r>=0&&r<ROWS&&c>=0&&c<COLS&&elevMap[r][c]===0) elevMap[r][c]=3;
    }
  }
  genScatter();
}


let scatterProps=[];
const PROP_TYPES=[
  {type:'crate',  icons:['ğŸ“¦'],colors:['#c8a878','#b89868'],r:7},
  {type:'barrel', icons:['ğŸ›¢'],colors:['#6a8090','#5a7080'],r:6},
  {type:'bench',  icons:['ğŸª‘'],colors:['#a08060','#907050'],r:5},
  {type:'light',  icons:['ğŸ’¡'],colors:['#fbbf24'],r:4,glow:true,light:true},
  {type:'cone',   icons:['ğŸ”º'],colors:['#f97316'],r:5},
  {type:'car',    icons:['ğŸš—','ğŸš™'],colors:['#6080a0','#a06040'],r:10},
];
function genScatter(){
  scatterProps=[];
  const count=80;
  for(let i=0;i<count;i++){
    const wx=80+Math.random()*(MAP_W-160);
    const wy=80+Math.random()*(MAP_H-160);
    if(isSolid(wx,wy))continue;
    if(dist(wx,wy,160,160)<100)continue;
    if(dist(wx,wy,MAP_W-160,MAP_H-160)<120)continue;
    const elv=getElev(wx,wy);
    // Only put cars on ground level roads
    const availTypes=elv===0?PROP_TYPES:PROP_TYPES.filter(p=>p.type!=='car');
    const pt=availTypes[Math.floor(Math.random()*availTypes.length)];
    const icon=pt.icons[Math.floor(Math.random()*pt.icons.length)];
    const color=pt.colors[Math.floor(Math.random()*pt.colors.length)];
    scatterProps.push({wx,wy,type:pt.type,icon,color,r:pt.r,glow:!!pt.glow,light:!!pt.light,elv,
      phase:Math.random()*Math.PI*2, scale:0.8+Math.random()*0.4});
  }
}

function isSolid(wx,wy){
  const c=Math.floor(wx/TILE),r=Math.floor(wy/TILE);
  if(r<0||r>=ROWS||c<0||c>=COLS)return true;
  return tileMap[r][c]===1;
}
function getElev(wx,wy){
  const c=Math.floor(wx/TILE),r=Math.floor(wy/TILE);
  if(r<0||r>=ROWS||c<0||c>=COLS)return 0;
  return elevMap[r][c]||0;
}
// Get smooth continuous height 0..1 for rendering
function getSmoothHeight(wx,wy){
  const c=wx/TILE,r=wy/TILE;
  const ic=Math.floor(c),ir=Math.floor(r);
  const fc=c-ic,fr=r-ir;
  function gh(rr,cc){
    if(rr<0||rr>=ROWS||cc<0||cc>=COLS)return 0;
    return heightMap[rr]?heightMap[rr][cc]||0:0;
  }
  const h00=gh(ir,ic),h10=gh(ir,ic+1),h01=gh(ir+1,ic),h11=gh(ir+1,ic+1);
  return h00*(1-fc)*(1-fr)+h10*fc*(1-fr)+h01*(1-fc)*fr+h11*fc*fr;
}
function canAttack(attackerElev,targetElev){
  // High hits all, mid hits mid+low, low hits only low
  return attackerElev>=targetElev;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENEMY DROP ROLLS â€” ä½¿ç”¨ gamedata.json çš„æ‰è½é…ç½®
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function rollEnemyDrops(enemyType){
  const t = enemyType || {};
  const drops = [];
  const allowedTiers = t._dropCrystalTiers && t._dropCrystalTiers.length ? t._dropCrystalTiers : [1,2];
  const minCrystals  = t._dropCrystalMin   || 2;
  const numDrops = minCrystals + Math.floor(Math.random()*2);

  for(let i=0;i<numDrops;i++){
    const elem = ELEMENTS[Math.floor(Math.random()*ELEMENTS.length)];
    const tier = allowedTiers[Math.floor(Math.random()*allowedTiers.length)];
    const crystal = getCrystal(elem, tier);
    if(crystal){
      const qty = 3+Math.floor(Math.random()*8);
      drops.push(Object.assign({},crystal,{qty}));
    }
  }

  // æ‰è½æ­¦å™¨
  const wandChance = t._dropWandChance != null ? t._dropWandChance : 0.25;
  if(Math.random() < wandChance){
    const pool = t._dropWandIds && t._dropWandIds.length
      ? t._dropWandIds.map(id=>WANDS.find(w=>w.id===id)).filter(Boolean)
      : WANDS;
    if(pool.length > 0)
      drops.push(Object.assign({}, pool[Math.floor(Math.random()*pool.length)]));
  }

  // æ‰è½é˜²å…·
  const armorChance = t._dropArmorChance != null ? t._dropArmorChance : 0.20;
  if(Math.random() < armorChance){
    const pool = t._dropArmorIds && t._dropArmorIds.length
      ? t._dropArmorIds.map(id=>ARMORS.find(a=>a.id===id)).filter(Boolean)
      : ARMORS;
    if(pool.length > 0)
      drops.push(Object.assign({}, pool[Math.floor(Math.random()*pool.length)]));
  }
  return drops;
}

function spawnEnemies(){
  enemies=[];
  for(let i=0;i<CONFIG.ENEMY_INITIAL;i++){
    let wx,wy,tries=0;
    do{wx=200+Math.random()*(MAP_W-400);wy=200+Math.random()*(MAP_H-400);tries++;}
    while((isSolid(wx,wy)||dist(wx,wy,160,160)<220)&&tries<60);
    const t=ENEMY_TYPES[Math.floor(Math.random()*ENEMY_TYPES.length)];
    const spawnElev=t.elev||getElev(wx,wy);
    // Pre-roll enemy drops at spawn
    const drops=rollEnemyDrops(t);
    // å¦‚æœ drop_wand_ids éç©ºï¼Œæ•Œäººè£…å¤‡ç¬¬ä¸€æŠŠæ­¦å™¨
    const equippedWand = (()=>{
      const pool = t._dropWandIds && t._dropWandIds.length
        ? t._dropWandIds.map(id=>WANDS.find(w=>w.id===id)).filter(Boolean)
        : [];
      return pool.length ? Object.assign({},pool[Math.floor(Math.random()*pool.length)]) : null;
    })();
    // å¦‚æœè£…å¤‡äº†æ­¦å™¨ï¼Œä»æ­¦å™¨ç»§æ‰¿æ”»å‡»å±æ€§
    const eDmg   = equippedWand ? (equippedWand.dmg[0]+equippedWand.dmg[1])/2 : t.dmg;
    const eRange = equippedWand ? equippedWand.range : (t.range||60);
    const eRate  = equippedWand ? equippedWand.spd   : (t.attackRate||1.0);
    const eColor = equippedWand ? equippedWand.proj   : t.color;
    enemies.push({wx,wy,hp:t.hp,maxHp:t.hp,spd:t.spd,dmg:eDmg,color:t.color,projColor:eColor,r:t.r,name:t.name,
      elev:spawnElev,attackCd:0,attackRate:eRate,aggroRange:t.aggroRange||200,wanderAngle:Math.random()*Math.PI*2,
      drops,slowTimer:0,dotTimer:0,
      ranged: equippedWand ? true : (t.ranged||false),
      range:  eRange,
      wand:   equippedWand,  // å­˜æ­¦å™¨å¼•ç”¨ï¼Œä¾›å¼¹ä¸¸å±æ€§ä½¿ç”¨
      phase:Math.random()*Math.PI*2});
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHESTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ç®±å­åˆ†çº§é…ç½®
const CHEST_GRADES = [
  { grade:'S', count:5,  color:0xffd700, emissive:0x442200, scale:0.55,
    loot:()=>{ // Sçº§ï¼šé«˜é˜¶æ³•æ–/é˜²å…·+å¤§é‡é«˜çº§çµæ™¶
      const items=[];
      const w=WANDS[Math.floor(Math.random()*WANDS.length)];
      items.push(Object.assign({},w));
      const a=ARMORS[Math.floor(Math.random()*ARMORS.length)];
      items.push(Object.assign({},a));
      // 2~3ç»„é«˜é˜¶çµæ™¶
      for(let n=0;n<2+Math.floor(Math.random()*2);n++){
        const elem=ELEMENTS[Math.floor(Math.random()*ELEMENTS.length)];
        const tier=Math.random()<0.5?4:3;
        const c=getCrystal(elem,tier);
        if(c) items.push(Object.assign({},c,{qty:10+Math.floor(Math.random()*20)}));
      }
      return items;
    }
  },
  { grade:'A', count:8,  color:0x818cf8, emissive:0x110033, scale:0.45,
    loot:()=>{
      const items=[];
      if(Math.random()<0.5){
        const w=WANDS[Math.floor(Math.random()*WANDS.length)];
        items.push(Object.assign({},w));
      } else {
        const a=ARMORS[Math.floor(Math.random()*ARMORS.length)];
        items.push(Object.assign({},a));
      }
      for(let n=0;n<2;n++){
        const elem=ELEMENTS[Math.floor(Math.random()*ELEMENTS.length)];
        const tier=Math.random()<0.6?2:3;
        const c=getCrystal(elem,tier);
        if(c) items.push(Object.assign({},c,{qty:8+Math.floor(Math.random()*12)}));
      }
      return items;
    }
  },
  { grade:'B', count:10, color:0x94a3b8, emissive:0x080808, scale:0.36,
    loot:()=>{
      const items=[];
      const pool=Math.random()<0.4?ARMORS:WANDS;
      if(Math.random()<0.35) items.push(Object.assign({},pool[Math.floor(Math.random()*pool.length)]));
      const elem=ELEMENTS[Math.floor(Math.random()*ELEMENTS.length)];
      const tier=Math.random()<0.7?1:2;
      const c=getCrystal(elem,tier);
      if(c) items.push(Object.assign({},c,{qty:5+Math.floor(Math.random()*10)}));
      return items;
    }
  },
];

function spawnChests(){
  chests=[];
  for(const gradeConf of CHEST_GRADES){
    for(let i=0;i<gradeConf.count;i++){
      let wx,wy,tries=0;
      do{wx=80+Math.random()*(MAP_W-160);wy=80+Math.random()*(MAP_H-160);tries++;}
      while(isSolid(wx,wy)&&tries<50);
      let lootItems=gradeConf.loot();
      // å…œåº•ï¼šè‡³å°‘ç»™ä¸€ä¸ªçµæ™¶ï¼Œé˜²æ­¢ç©ºç®±
      if(!lootItems||lootItems.length===0){
        const c=getCrystal(ELEMENTS[Math.floor(Math.random()*ELEMENTS.length)],1);
        if(c) lootItems=[Object.assign({},c,{qty:5})];
      }
      const mainItem=lootItems&&lootItems[0]?lootItems[0]:null;
      const extraLoot=lootItems?lootItems.slice(1):[];
      chests.push({
        wx,wy,
        wand:mainItem,
        extraLoot,
        opened:false,
        gp:Math.random()*Math.PI*2,
        grade:gradeConf.grade,
        gradeColor:gradeConf.color,
        gradeScale:gradeConf.scale,
        gradeEmissive:gradeConf.emissive,
      });
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const INV_COLS=6,INV_ROWS=4;
const CELL=30,GAP=2;  // èƒŒåŒ…æ ¼å­å°ºå¯¸

function initPlayer(){
  player={
    wx:160,wy:160,
    hp:100,maxHp:100,
    baseSpd:2.9,spd:2.9,r:12,
    baseDef:0,def:0,
    inventory:[],
    equippedWeapon:null,  // å½“å‰è£…å¤‡çš„æ­¦å™¨ï¼ˆä¸åœ¨èƒŒåŒ…é‡Œï¼‰

    attackCd:0,
    elev:0,prevElev:0,
    // Elevation jump animation
    elevAnimT:0,      // 0..1 animation progress
    elevAnimDir:0,    // +1 up, -1 down
    visualElevOffset:0, // current visual Y offset (animated)
  };
  // æ­¦å™¨ç›´æ¥è£…å¤‡åˆ° equippedWeaponï¼ˆä¸æ”¾èƒŒåŒ…ï¼‰
  if(equipSlots.weapon){
    player.equippedWeapon=Object.assign({},equipSlots.weapon);
  }
  // Load bag items
  bagLoadout.forEach(it=>{ if(it) placeItemInGrid(it); });
  // Load ammo into player ammo pool
  player.ammoPool=[];
  ammoSlots.forEach(a=>{ if(a&&a.crystal) player.ammoPool.push({crystal:Object.assign({},a.crystal),qty:a.qty}); });
  // Set armor bonuses from equipped slots (applied directly, not in inventory)
  player.equippedArmor=equipSlots.armor?Object.assign({},equipSlots.armor):null;
  player.equippedBoots=equipSlots.boots?Object.assign({},equipSlots.boots):null;
  player.equippedAcc=equipSlots.acc?Object.assign({},equipSlots.acc):null;
  recalcStats();
  updateInvGrid();
}

function recalcStats(){
  player.def=0;
  const baseSpd=player.baseSpd||2.9;
  let spdBonus=0,hpBonus=0;
  // From equipped armor slots
  if(player.equippedArmor) player.def+=(player.equippedArmor.def||0);
  if(player.equippedBoots) spdBonus+=(player.equippedBoots.spd||0);
  if(player.equippedAcc){
    hpBonus+=(player.equippedAcc.maxHp||0);
  }
  player.spd=Math.min(baseSpd+spdBonus,6);
  const newMaxHp=(CONFIG.PLAYER_HP||100)+hpBonus;
  if(newMaxHp>player.maxHp) player.hp+=newMaxHp-player.maxHp;
  player.maxHp=newMaxHp;
  player.hp=Math.min(player.hp,player.maxHp);
}

function placeItemInGrid(itemData){
  const it={...itemData};
  const [sw,sh]=it.size;
  for(let gy=0;gy<=INV_ROWS-sh;gy++){
    for(let gx=0;gx<=INV_COLS-sw;gx++){
      if(canPlace(gx,gy,sw,sh)){
        const entry={item:it,gx,gy,equipped:false};
        player.inventory.push(entry);
        // Auto-equip first wand
        if(player.equippedIdx===null && !it.type) player.equippedIdx=player.inventory.length-1;
        return true;
      }
    }
  }
  return false;
}
// Keep old name as alias for wands
function placeWandInGrid(wand){ return placeItemInGrid(wand); }

function canPlace(gx,gy,sw,sh,excludeIdx=null){
  for(let i=0;i<player.inventory.length;i++){
    if(i===excludeIdx)continue;
    const entry=player.inventory[i];
    const it=entry.item||entry.wand;
    if(!it)continue;
    const [isw,ish]=it.size;
    if(gx<entry.gx+isw&&gx+sw>entry.gx&&gy<entry.gy+ish&&gy+sh>entry.gy)return false;
  }
  return true;
}

function getEquipped(){
  return player.equippedWeapon || null;
}


function updateInvGrid(){
  const grid=document.getElementById('inv-grid');
  grid.innerHTML='';
  for(let r=0;r<INV_ROWS;r++)for(let c=0;c<INV_COLS;c++){
    const cell=document.createElement('div');cell.className='inv-cell';grid.appendChild(cell);
  }
  player.inventory.forEach((entry,idx)=>{
    const it=entry.item||entry.wand;
    if(!it)return;
    const [sw,sh]=it.size;
    const isWand=!it.type;
    const isEquippedWand=isWand&&player.equippedIdx===idx;
    const isEquippedArmor=entry.equipped;
    const isEq=isEquippedWand||isEquippedArmor;
    const isSel=selectedInvIdx===idx;
    const block=document.createElement('div');
    block.className='inv-item-block'+(isSel?' selected':'')+(isEq?' is-equipped':'');
    block.style.cssText=
      `left:${entry.gx*(CELL+GAP)}px;`+
      `top:${entry.gy*(CELL+GAP)}px;`+
      `width:${sw*CELL+(sw-1)*GAP}px;`+
      `height:${sh*CELL+(sh-1)*GAP}px;`+
      `background:${it.color}28;`+
      `border-color:${isEq?'#4ade80':it.color+'99'};`+
      `color:${it.color};`;
    // Type badge color
    const typeColor=it.type==='armor'?'#94a3b8':it.type==='boots'?'#4ade80':it.type==='acc'?'#fbbf24':'#c084fc';
    block.innerHTML=
      `<span style="font-size:16px;line-height:1">${it.icon}</span>`+
      `<span class="inv-item-name" style="color:${typeColor}">${it.name.split(' ')[0]}</span>`+
      (isEq?`<span style="font-size:5px;color:#4ade80;line-height:1">â–¶EQ</span>`:'');
    block.title=`${it.name}\n${it.desc||''}`;
    block.onclick=()=>{
      selectedInvIdx=(selectedInvIdx===idx)?null:idx;
      updateInvGrid();
      document.getElementById('btn-equip').disabled=selectedInvIdx===null;
      document.getElementById('btn-drop').disabled=selectedInvIdx===null;
      // handled below
    };
    grid.appendChild(block);
  });
  document.getElementById('inv-weight').textContent=`${player.inventory.length} / 8 slots`;

  const w=getEquipped();
  document.getElementById('weapon-name').textContent=w?w.name:'BARE HANDS';
  // Stats line: weapon + armor bonuses
  const defStr=player.def>0?` Â· DEF ${player.def}`:'';
  const spdStr=player.spd>3?` Â· SPD ${player.spd.toFixed(1)}`:'';
  document.getElementById('weapon-stats').textContent=
    w?`DMG ${w.dmg[0]}â€“${w.dmg[1]} Â· RNG ${w.range}${defStr}${spdStr}`:`æ— æ­¦å™¨${defStr}${spdStr}`;
  document.getElementById('hp-fill').style.width=(player.hp/player.maxHp*100)+'%';

}

function equipSelected(){
  if(selectedInvIdx===null)return;
  const entry=player.inventory[selectedInvIdx];
  const it=entry.item||entry.wand;
  if(!it)return;

  if(!it.type){
    // æ­¦å™¨ï¼šç§»å‡ºèƒŒåŒ…ï¼Œæ”¾åˆ° player.equippedWeapon
    const old=player.equippedWeapon;
    player.equippedWeapon=Object.assign({},it);
    player.inventory.splice(selectedInvIdx,1);
    // å¦‚æœæœ‰æ—§æ­¦å™¨ï¼Œæ”¾å›èƒŒåŒ…
    if(old) placeItemInGrid(old);
    addLog(`è£…å¤‡æ­¦å™¨: ${it.name}`,'info');
  } else if(it.type==='armor'){
    const old=player.equippedArmor;
    player.equippedArmor=Object.assign({},it);
    player.inventory.splice(selectedInvIdx,1);
    if(old) placeItemInGrid(old);
    addLog(`è£…å¤‡é˜²å…·: ${it.name}`,'info');
    recalcStats();
  } else if(it.type==='boots'){
    const old=player.equippedBoots;
    player.equippedBoots=Object.assign({},it);
    player.inventory.splice(selectedInvIdx,1);
    if(old) placeItemInGrid(old);
    addLog(`è£…å¤‡é‹å­: ${it.name}`,'info');
    recalcStats();
  } else if(it.type==='acc'){
    const old=player.equippedAcc;
    player.equippedAcc=Object.assign({},it);
    player.inventory.splice(selectedInvIdx,1);
    if(old) placeItemInGrid(old);
    addLog(`è£…å¤‡é¥°å“: ${it.name}`,'info');
    recalcStats();
  } else if(it.type==='crystal'){
    // å¼¹è¯ï¼šåŠ å…¥å¼¹è¯æ± 
    const existing=player.ammoPool.find(a=>a.crystal.id===it.id);
    if(existing){ existing.qty+=it.qty||1; }
    else { player.ammoPool.push({crystal:Object.assign({},it),qty:it.qty||1}); }
    player.inventory.splice(selectedInvIdx,1);
    addLog(`è£…å¡«å¼¹è¯: ${it.name} Ã—${it.qty||1}`,'info');
    updateAmmoHud();
  }

  selectedInvIdx=null;
  updateInvGrid();
  renderRaidEquipSlots();
}


function sellFromBackpack(){ }
function sellFromInventory(){
  if(selectedInvIdx===null)return;
  const entry=player.inventory[selectedInvIdx];
  if(!entry)return;
  const it=entry.item||entry.wand;
  if(!it)return;
  // Use market price or base price
  const price=marketPrices[it.id]||it.basePrice||20;
  // If crystal, sell stack
  const qty=it.qty||1;
  const total=it.type==='crystal'?Math.floor(price*qty):price;
  gold+=total;
  player.inventory.splice(selectedInvIdx,1);
  selectedInvIdx=null;
  updateInvGrid();
  document.getElementById('btn-equip').disabled=true;
  document.getElementById('btn-drop').disabled=true;
  document.getElementById('btn-sell-inv').disabled=true;
  document.getElementById('gold-display').textContent='â—ˆ '+gold;
  addLog(`å”®å‡º ${it.name} +â—ˆ${total}`,'loot');
}


function sellFromBackpack(){
  if(selectedInvIdx===null)return;
  const entry=player.inventory[selectedInvIdx];
  if(!entry)return;
  const it=entry.item||entry.wand;
  const price=marketPrices[it.id]||it.basePrice||0;
  const sellPrice=Math.floor(price*0.8);
  gold+=sellPrice;
  player.inventory.splice(selectedInvIdx,1);
  selectedInvIdx=null;
  updateInvGrid();
  document.getElementById('gold-display').textContent=`â—ˆ ${gold}`;
  addLog(`å–å‡º ${it.name} +â—ˆ${sellPrice}`,'loot');
}
function dropSelected(){
  if(selectedInvIdx===null)return;
  const entry=player.inventory.splice(selectedInvIdx,1)[0];
  const it=entry.item||entry.wand;
  droppedWands.push({
    wx:player.wx+Math.cos(Math.random()*Math.PI*2)*20,
    wy:player.wy+Math.sin(Math.random()*Math.PI*2)*20,
    wand:it  // keep field name for compat
  });
  if(player.equippedIdx>=player.inventory.length)player.equippedIdx=player.inventory.length>0?0:null;
  selectedInvIdx=null;
  document.getElementById('btn-equip').disabled=true;
  document.getElementById('btn-drop').disabled=true;
  recalcStats();
  addLog(`ä¸¢å¼ƒ: ${it.name}`,'info');
  updateInvGrid();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PICKUP SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updatePickup(dt){
  if(!pickupTarget){
    pickupProgress=0;
    document.getElementById('pickup-bar-wrap').style.display='none';
    return;
  }
  const d=dist(player.wx,player.wy,pickupTarget.wx,pickupTarget.wy);
  if(d>PICKUP_RANGE){
    // Left range, reset
    pickupProgress=0;
    pickupTarget=null;
    document.getElementById('pickup-bar-wrap').style.display='none';
    addLog('æ‹¾å–ä¸­æ–­','info');
    return;
  }
  pickupProgress+=dt/PICKUP_TIME;
  document.getElementById('pickup-bar-wrap').style.display='flex';
  document.getElementById('pickup-fill').style.width=(pickupProgress*100)+'%';
  document.getElementById('pickup-label').textContent='LOOTING: '+getLootName(pickupTarget);

  if(pickupProgress>=1){
    finishPickup();
  }
}

// å½“å‰æ‰“å¼€çš„æˆ˜åˆ©å“æºï¼ˆchest æˆ– droppedWandï¼‰
let lootSource = null;
let lootItems  = [];   // [{item, qty}] æˆ˜åˆ©å“é¢æ¿å†…å®¹
let selectedLoot = null;  // é€‰ä¸­çš„æˆ˜åˆ©å“ç´¢å¼•

function finishPickup(){
  if(!pickupTarget)return;
  // æ‰“å¼€æˆ˜åˆ©å“é¢æ¿è€Œä¸æ˜¯ç›´æ¥æ”¾å…¥èƒŒåŒ…
  openLootPanel(pickupTarget);
  document.getElementById('pickup-bar-wrap').style.display='none';
  pickupProgress=0; pickupHolding=false;
  pickupTarget=null;
}

function openLootPanel(source){
  lootSource = source;
  lootItems  = [];
  // æ”¶é›†æˆ˜åˆ©å“
  const wand = source.wand;
  if(wand){
    // ç®±å­/æ‰è½ç‰©çš„ä¸»ç‰©å“
    lootItems.push({item: wand, qty: wand.qty||1});
  }
  // å¦‚æœæ˜¯ç®±å­ï¼Œè¿˜æœ‰é¢å¤–æ‰è½
  if(source.extraLoot){
    source.extraLoot.forEach(it => lootItems.push({item:it, qty:it.qty||1}));
  }
  selectedLoot = null;
  renderLootPanel();
  showLootPanel();
  const srcName = wand ? wand.name : 'UNKNOWN';
  document.getElementById('loot-source-name').textContent = srcName;
}

function closeLootPanel(){
  // æœªæ‹¿èµ°çš„ç‰©å“å˜æˆåœ°é¢æ‰è½ï¼ˆç•™åœ¨åŸä½ï¼‰
  if(lootSource && lootItems.length > 0){
    lootItems.forEach(({item})=>{
      droppedWands.push({
        wx: lootSource.wx + (Math.random()-0.5)*30,
        wy: lootSource.wy + (Math.random()-0.5)*30,
        wand: item
      });
    });
    // ä»åŸæ¥å®¹å™¨ä¸­ç§»é™¤
    const ci = chests.findIndex(c=>c===lootSource);
    if(ci>=0){ chests[ci].opened=true; }
    else {
      const di = droppedWands.findIndex(d=>d===lootSource);
      if(di>=0) droppedWands.splice(di,1);
    }
  }
  lootSource=null; lootItems=[];
  hideLootPanel();
}

function renderLootPanel(){
  const grid = document.getElementById('loot-grid');
  grid.innerHTML='';
  lootItems.forEach((entry, i)=>{
    const {item, qty} = entry;
    const cell = document.createElement('div');
    cell.className = 'loot-cell' + (selectedLoot===i?' selected':'');
    cell.innerHTML = `<span>${item.icon||'ğŸ“¦'}</span><span class="lc-name">${item.name}</span>${qty>1?`<span class="lc-qty">Ã—${qty}</span>`:''}`;
    cell.onclick = ()=>{ selectedLoot=i; renderLootPanel(); document.getElementById('btn-loot-take').disabled=false; };
    grid.appendChild(cell);
  });
  if(lootItems.length===0){
    grid.innerHTML='<div style="color:#4a4a60;font-size:8px;padding:10px;grid-column:1/-1">EMPTY</div>';
  }
}

function lootSelected(){
  if(selectedLoot===null || selectedLoot>=lootItems.length) return;
  const {item, qty} = lootItems[selectedLoot];
  const placed = placeItemInGrid(Object.assign({},item,{qty}));
  if(!placed){ addLog('èƒŒåŒ…å·²æ»¡','imp'); return; }
  lootItems.splice(selectedLoot,1);
  selectedLoot=null;
  document.getElementById('btn-loot-take').disabled=true;
  renderLootPanel();
  updateInvGrid();
  if(lootItems.length===0) closeLootPanelSilent();
}

function lootAll(){
  const failed=[];
  lootItems.forEach(({item,qty})=>{
    if(!placeItemInGrid(Object.assign({},item,{qty}))) failed.push(item);
  });
  if(failed.length){ addLog('èƒŒåŒ…å·²æ»¡ï¼Œéƒ¨åˆ†æœªå–','imp'); lootItems=failed.map(item=>({item,qty:item.qty||1})); }
  else lootItems=[];
  renderLootPanel();
  updateInvGrid();
  if(lootItems.length===0) closeLootPanelSilent();
}

function closeLootPanelSilent(){
  // é™é»˜å…³é—­ï¼ˆç‰©å“å·²å…¨å–èµ°ï¼‰
  if(lootSource){
    const ci=chests.findIndex(c=>c===lootSource);
    if(ci>=0) chests[ci].opened=true;
    else{
      const di=droppedWands.findIndex(d=>d===lootSource);
      if(di>=0) droppedWands.splice(di,1);
    }
  }
  lootSource=null; lootItems=[];
  hideLootPanel();
}


// è·å–å¯æ‹¾å–å¯¹è±¡çš„æ˜¾ç¤ºåç§°
function getLootName(source){
  if(!source) return 'ITEM';
  if(source.wand && source.wand.name) return source.wand.name;
  if(source.extraLoot && source.extraLoot.length>0 && source.extraLoot[0].name)
    return source.extraLoot[0].name;
  if(source.isCorpse) return 'LOOT';
  return source.grade ? source.grade+' CHEST' : 'CHEST';
}

function tryStartPickup(){
  // Find nearest lootable
  let best=null,bestD=PICKUP_RANGE;
  for(const ch of chests){
    if(ch.opened)continue;
    const d=dist(player.wx,player.wy,ch.wx,ch.wy);
    if(d<bestD){bestD=d;best=ch;}
  }
  for(const dw of droppedWands){
    const d=dist(player.wx,player.wy,dw.wx,dw.wy);
    if(d<bestD){bestD=d;best=dw;}
  }
  if(best){
    if(pickupTarget===best)return; // already looting this
    pickupTarget=best;
    pickupProgress=0;
    addLog(`å¼€å§‹æ‹¾å– ${getLootName(best)}...`,'info');
  }
}

function startPickupTouch(e){e.preventDefault();tryStartPickup();}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PARTICLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function spawnParticles(wx,wy,color,count=8,speed=2){
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2,s=Math.random()*speed+.5;
    particles.push({wx,wy,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:1,maxLife:1,color,r:Math.random()*4+1});
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function playerShoot(dt){
  const w=player.equippedWeapon||null;
  const rate=w?w.spd:1.2;
  player.attackCd-=dt;
  if(player.attackCd>0)return;
  const range=w?w.range:40;
  const pElev=getElev(player.wx,player.wy);

  let closest=null,closestD=Infinity;
  for(const e of enemies){
    if(!canAttack(pElev,e.elev))continue;
    const d=dist(player.wx,player.wy,e.wx,e.wy);
    if(d<range&&d<closestD){closestD=d;closest=e;}
  }
  if(!closest)return;

  // å¼¹è¯å€ç‡
  let dmgMult=1;
  if(w&&player.ammoPool&&player.ammoPool.length>0){
    const elem=WAND_ELEM[w.id];
    const match=player.ammoPool.find(a=>a.crystal.elem===elem&&a.qty>0);
    if(match){dmgMult=match.crystal.dmgMult;match.qty--;if(match.qty<=0)player.ammoPool.splice(player.ammoPool.indexOf(match),1);updateAmmoHud();}
    else{
      // æ— åŒ¹é…å¼¹è¯ï¼šç”¨ä»»æ„å¼¹è¯ä½†å€ç‡å‡åŠ
      const any=player.ammoPool.find(a=>a.qty>0);
      if(any){dmgMult=any.crystal.dmgMult*0.5;any.qty--;if(any.qty<=0)player.ammoPool.splice(player.ammoPool.indexOf(any),1);updateAmmoHud();}
    }
  }

  player.attackCd=1/rate;
  const [nx,ny]=normalize(closest.wx-player.wx,closest.wy-player.wy);
  const baseDmg=(w?w.dmg[0]:5)+Math.random()*((w?w.dmg[1]:8)-(w?w.dmg[0]:5));
  const projSpd=12;
  const projRange=w?w.range:40;
  projectiles.push({
    wx:player.wx,wy:player.wy,
    vx:nx*projSpd,vy:ny*projSpd,
    dmg:baseDmg*dmgMult,
    color:w?w.proj:'#e2e8f0',
    life:projRange/projSpd,   // é£è¡Œæ—¶é—´ = å°„ç¨‹/é€Ÿåº¦
    r:w&&w.aoe>0?8:5,
    aoe:w?w.aoe:0,pierce:w?!!w.pierce:false,
    slow:w?!!w.slow:false,vamp:w?!!w.vamp:false,
    dot:w?!!w.dot:false,
    fromElev:pElev,
    hit:new Set(),
  });
}

function updateEnemies(dt){
  for(const e of enemies){
    e.phase+=dt;
    const d=dist(player.wx,player.wy,e.wx,e.wy);
    const pElev=getElev(player.wx,player.wy);

    if(d<e.aggroRange){
      const [nx,ny]=normalize(player.wx-e.wx,player.wy-e.wy);
      const spd=(e.slowTimer>0)?e.spd*0.3:e.spd*0.55;  // å¤§å¹…é™é€Ÿï¼Œå‡é€ŸçŠ¶æ€æ›´æ…¢
      const nx2=e.wx+nx*spd,ny2=e.wy+ny*spd;
      if(!isSolid(nx2,e.wy))e.wx=nx2;
      if(!isSolid(e.wx,ny2))e.wy=ny2;
      e.elev=getElev(e.wx,e.wy);
    }else{
      e.wanderAngle+=(Math.random()-.5)*.2;
      const nx2=e.wx+Math.cos(e.wanderAngle)*.6,ny2=e.wy+Math.sin(e.wanderAngle)*.6;
      if(!isSolid(nx2,e.wy))e.wx=nx2;else e.wanderAngle+=Math.PI/2;
      if(!isSolid(e.wx,ny2))e.wy=ny2;
      e.elev=getElev(e.wx,e.wy);
    }

    if(e.slowTimer>0)e.slowTimer-=dt;
    if(e.dotTimer>0){e.dotTimer-=dt;e.hp-=dt*4;}

    // Attack player
    if(canAttack(e.elev,pElev)){
      e.attackCd-=dt;
      if(e.ranged){
        // è¿œç¨‹ï¼šåœ¨å°„ç¨‹å†…å‘å°„å¼¹ä¸¸ï¼Œä¸éœ€è¦è´´è¿‘
        if(d < e.range && e.attackCd<=0){
          e.attackCd=1/e.attackRate;
          const ang=Math.atan2(player.wy-e.wy,player.wx-e.wx);
          const eProjSpd=12;
          const ew=e.wand;
          projectiles.push({
            wx:e.wx+Math.cos(ang)*e.r,
            wy:e.wy+Math.sin(ang)*e.r,
            vx:Math.cos(ang)*eProjSpd,
            vy:Math.sin(ang)*eProjSpd,
            dmg:e.dmg,
            color:e.projColor||e.color,
            r:ew&&ew.aoe>0?8:6,
            life:e.range/eProjSpd,   // å°„ç¨‹é™åˆ¶
            fromElev:e.elev,
            fromEnemy:true,
            hit:new Set(),
            aoe:ew?ew.aoe:0,
            pierce:ew?!!ew.pierce:false,
            slow:ew?!!ew.slow:false,
            dot:ew?!!ew.dot:false,
            vamp:false,
          });
        }else if(d>=e.range){e.attackCd=Math.max(0,e.attackCd-dt);}
      } else {
        // è¿‘æˆ˜
        if(d<e.r+player.r+8){
          if(e.attackCd<=0){
            e.attackCd=1/e.attackRate;
            const rawDmg=e.dmg+Math.random()*4-2;
            const dmg=Math.max(1,rawDmg-player.def*0.4);
            player.hp=Math.max(0,player.hp-dmg);
            addLog(`${e.name} é€ æˆ ${Math.round(dmg)} ä¼¤å®³`+(player.def>0?` (å‡å…${Math.round(rawDmg-dmg)})`:''),'dmg');
            updateInvGrid();
            if(player.hp<=0)killPlayer();
          }
        }else{e.attackCd=Math.max(0,e.attackCd-dt);}
      }
    }else{e.attackCd=Math.max(0,e.attackCd-dt);}
  }
}

function updateProjectiles(dt){
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    p.wx+=p.vx;p.wy+=p.vy;
    p.life-=dt;
    if(p.life<=0||isSolid(p.wx,p.wy)){projectiles.splice(i,1);continue;}

    let killed=false;

    // æ•Œäººå¼¹ä¸¸ï¼šåªæ‰“ç©å®¶
    if(p.fromEnemy){
      if(dist(p.wx,p.wy,player.wx,player.wy)<player.r+p.r){
        const rawDmg=p.dmg+Math.random()*4-2;
        const dmg=Math.max(1,rawDmg-player.def*0.4);
        player.hp=Math.max(0,player.hp-dmg);
        addLog(`è¿œç¨‹æ”»å‡»å‘½ä¸­ ${Math.round(dmg)} ä¼¤å®³`+(player.def>0?` (å‡å…${Math.round(rawDmg-dmg)})`:''),'dmg');
        spawnParticles(player.wx,player.wy,p.color,4,1.5);
        updateInvGrid();
        if(player.hp<=0)killPlayer();
        projectiles.splice(i,1);
        continue;
      }
      continue; // æ•Œäººå¼¹ä¸¸ä¸æ‰“æ•Œäºº
    }

    // ç©å®¶å¼¹ä¸¸ï¼šæ‰“æ•Œäºº
    for(const e of enemies){
      if(p.hit.has(e))continue;
      if(!canAttack(p.fromElev,e.elev))continue;
      if(dist(p.wx,p.wy,e.wx,e.wy)<e.r+p.r){
        p.hit.add(e);
        e.hp-=p.dmg;
        if(p.slow)e.slowTimer=2.5;
        if(p.dot)e.dotTimer=3;
        if(p.vamp)player.hp=Math.min(player.maxHp,player.hp+p.dmg*.3);
        spawnParticles(e.wx,e.wy,p.color,5,2);
        if(p.aoe>0){
          for(const e2 of enemies){
            if(dist(p.wx,p.wy,e2.wx,e2.wy)<p.aoe+e2.r){
              e2.hp-=p.dmg*.5;
              spawnParticles(e2.wx,e2.wy,p.color,3,1.5);
            }
          }
        }
        if(!p.pierce){projectiles.splice(i,1);killed=true;break;}
      }
    }
    if(killed)continue;
  }

  // æ­»äº¡å¤„ç†æ”¾åˆ°å¾ªç¯å¤–ï¼Œé¿å…åœ¨è¿­ä»£ä¸­ä¿®æ”¹æ•°ç»„
  const dead=enemies.filter(e=>e.hp<=0);
  for(const e2 of dead){
    addLog(`å‡»æ€ ${e2.name}`,'imp');
    spawnParticles(e2.wx,e2.wy,e2.color,20,4);

    // æ­»äº¡ååœ¨åŸåœ°ç”Ÿæˆå¯æ‹¾å–é—éª¸ç®±
    {
      // é—éª¸ç®±ï¼šè‹¥æ— é¢„æ»šæ‰è½åˆ™ç°åœºç”Ÿæˆä¸€ä¸ªçµæ™¶
      const rawDrops = (e2.drops&&e2.drops.length>0) ? e2.drops : (()=>{
        const el=ELEMENTS[Math.floor(Math.random()*ELEMENTS.length)];
        const c=getCrystal(el,1); return c?[Object.assign({},c,{qty:3+Math.floor(Math.random()*5)})] : [];
      })();
      const mainItem = rawDrops.length>0 ? Object.assign({},rawDrops[0]) : {name:'CRYSTAL SHARD',icon:'ğŸ’ ',type:'crystal',qty:1,basePrice:5,size:[1,1]};
      const extraItems=rawDrops.slice(1).map(it=>Object.assign({},it));
      const corpse={
        wx:e2.wx, wy:e2.wy,
        wand:mainItem,
        extraLoot:extraItems,
        opened:false,
        gp:0,
        grade:'drop',
        gradeColor:0xcc4444,
        gradeEmissive:0x220000,
        gradeScale:0.3,
        isCorpse:true,
      };
      chests.push(corpse);
      // ç«‹å³åœ¨3Dåœºæ™¯å»ºmesh
      const sc=0.3;
      const mat=new THREE.MeshLambertMaterial({color:0xcc4444,emissive:0x220000});
      const box=new THREE.Mesh(new THREE.BoxGeometry(U*sc,U*sc*0.7,U*sc),mat);
      box.position.set(e2.wx,U*sc*0.35,e2.wy);
      scene3.add(box);
      chestMeshes3.push(box);
      const pillarMat=new THREE.MeshBasicMaterial({color:0xcc4444});
      const pillar=new THREE.Mesh(new THREE.CylinderGeometry(2,2,U*0.5,6),pillarMat);
      pillar.position.set(e2.wx,U*sc*0.7+U*0.25,e2.wy);
      scene3.add(pillar);
      chestMeshes3.push(pillar);

      const label=e2.drops.map(it=>it.type==='crystal'?`${it.name}Ã—${it.qty||1}`:it.name).join(', ');
      addLog(`æ‰è½: ${label}`,'loot');
    }

    enemies.splice(enemies.indexOf(e2),1);
  }
}



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEATH / EXTRACT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function killPlayer(){
  if(gameState!=='playing')return;
  gameState='dead';
  player.inventory.forEach((item,i)=>{
    const a=(i/player.inventory.length)*Math.PI*2;
    droppedWands.push({wx:player.wx+Math.cos(a)*35,wy:player.wy+Math.sin(a)*35,wand:item.wand});
  });
  spawnParticles(player.wx,player.wy,'#e53e3e',30,6);
  const ds=document.getElementById('death-screen');
  ds.style.display='flex';
  document.getElementById('death-msg').textContent=`é˜µäº¡ â€” èƒŒåŒ…ç‰©å“å·²æ‰è½ Â· å®¶å›­ä»“åº“å®‰å…¨`;
}

const extractPoint={wx:MAP_W-150,wy:MAP_H-150};

function checkExtract(){
  if(dist(player.wx,player.wy,extractPoint.wx,extractPoint.wy)<50){
    gameState='extracted';
    // Move inventory to stash
    // Return inventory items to stash
    const gained=player.inventory.map(i=>i.item||i.wand);
    gained.forEach(w=>addToStash({...w}));
    // Return unused ammo to stash
    if(player.ammoPool){
      player.ammoPool.filter(a=>a.qty>0).forEach(a=>{
        addToStash(Object.assign({},a.crystal,{qty:a.qty}));
      });
    }
    const es=document.getElementById('extract-screen');
    es.style.display='flex';
    document.getElementById('extract-summary').innerHTML=
      `æ’¤ç¦»æˆåŠŸï¼<br><br>`+
      (gained.length>0?gained.map(w=>`${w.icon} ${w.name}`).join('<br>'): 'ç©ºæ‰‹æ’¤ç¦»')+
      `<br><br>å·²å­˜å…¥ä»“åº“`;
  }
}

function goHomebase(){
  gameState='homebase';
  document.getElementById('death-screen').style.display='none';
  document.getElementById('extract-screen').style.display='none';
  document.getElementById('hud').style.display='none';
  document.getElementById('homebase').style.display='flex';
  document.getElementById('touch-btns').style.display='none';
  document.getElementById('joystick-base').style.display='none';
  refreshMarket();
  renderHomebase();
  // Auto-save on return to base
  if(currentUser&&currentSlot) saveGame();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HOMEBASE UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderHomebase(){
  document.getElementById('hb-gold-val').textContent=gold;

  // â”€â”€ STASH â”€â”€
  const sg=document.getElementById('storage-grid');
  sg.innerHTML='';
  const stashSlots=20;
  for(let i=0;i<stashSlots;i++){
    const slot=document.createElement('div');
    const it=stash[i];
    const isSel=selectedStorage===i;
    slot.className='storage-slot'+(it?' occupied':'')+(isSel?' selected-storage':'');
    if(it){
      const isStack=it.type==='crystal';
      slot.innerHTML=`<div style="font-size:${isStack?16:18}px">${it.icon}</div>`+
        (isStack?`<div style="font-size:8px;font-weight:bold;color:${it.color}">${it.qty||1}</div>`:'') +
        `<div class="slot-name">${it.name.split('Â·')[0]}</div>`;
      if(isSel)slot.style.borderColor='#fbbf24';
    }
    slot.onclick=()=>{
      if(!it){selectedStorage=null;selectedEquipSlot=null;selectedAmmoSlot=null;selectedLoadout=null;}
      else{selectedStorage=(isSel?null:i);}
      updateLoadoutHint();
      renderHomebase();
    };
    sg.appendChild(slot);
  }

  // â”€â”€ EQUIPMENT SLOTS â”€â”€
  ['weapon','armor','boots','acc'].forEach(type=>{
    const slotEl=document.getElementById(`eslot-${type}`);
    const it=equipSlots[type];
    const isSel=selectedEquipSlot===type;
    if(it){
      slotEl.className='equip-slot filled'+(isSel?' selected':'');
      slotEl.style.borderColor=it.color+'88';
      slotEl.innerHTML=
        `<span class="eslot-icon">${it.icon}</span>`+
        `<span class="eslot-name">${it.name.split(' ')[0]}</span>`+
        `<span class="eslot-del" onclick="unequipSlot('${type}',event)" title="å¸ä¸‹é€€å›ä»“åº“">âœ•</span>`+
        `<span style="position:absolute;bottom:2px;right:3px;font-size:5px;color:#d97706;cursor:pointer" onclick="sellEquippedItem('${type}',event)" title="ç›´æ¥å–æ‰">å–</span>`;
    } else {
      slotEl.className='equip-slot'+(isSel?' selected':'');
      const empIcon={'weapon':'âš”','armor':'ğŸ›¡','boots':'ğŸ‘¢','acc':'ğŸ’'}[type];
      slotEl.innerHTML=`<span class="eslot-empty">${empIcon}</span>`;
    }
  });

  // â”€â”€ AMMO SLOTS â”€â”€
  for(let i=0;i<4;i++){
    const slotEl=document.getElementById(`aslot-${i}`);
    const a=ammoSlots[i];
    const isSel=selectedAmmoSlot===i;
    if(a&&a.crystal){
      slotEl.className='ammo-slot filled'+(isSel?' selected':'');
      slotEl.style.borderColor=a.crystal.color+'88';
      slotEl.innerHTML=
        `<span class="aslot-icon">${a.crystal.icon}</span>`+
        `<span class="aslot-count" style="color:${a.crystal.color}">${a.qty}</span>`+
        `<span class="aslot-name">${a.crystal.name.split('Â·')[0]} T${a.crystal.tier}</span>`+
        `<span class="aslot-del" onclick="clearAmmoSlot(${i},event)">âœ•</span>`;
    } else {
      slotEl.className='ammo-slot'+(isSel?' selected':'');
      slotEl.innerHTML=`<span class="aslot-empty">+</span>`;
    }
  }

  // â”€â”€ BAG LOADOUT â”€â”€
  const lg=document.getElementById('loadout-grid');
  lg.innerHTML='';
  for(let i=0;i<4;i++){
    const slot=document.createElement('div');
    const it=bagLoadout[i];
    const isSel=selectedLoadout===i;
    slot.className='loadout-slot'+(it?' occupied':'')+(isSel?' selected-loadout':'');
    if(it){
      const isStack=it.type==='crystal';
      slot.innerHTML=`<div style="font-size:16px">${it.icon}</div>`+
        (isStack?`<div style="font-size:7px;color:${it.color}">${it.qty||1}å‘</div>`:'') +
        `<div class="slot-name">${it.name.split(' ')[0]}</div>`;
      slot.style.borderColor=it.color+'66';
    } else if(selectedStorage!==null&&stash[selectedStorage]){
      slot.style.borderColor='#fbbf2444';
      slot.innerHTML=`<div style="font-size:11px;color:#fbbf2444">+</div>`;
    }
    slot.onclick=()=>{
      if(selectedStorage!==null&&stash[selectedStorage]&&!it){
        // Place stash item into bag slot
        bagLoadout[i]=Object.assign({},stash[selectedStorage]);
        stash.splice(selectedStorage,1);
        selectedStorage=null;
        updateLoadoutHint();
        renderHomebase();
      } else if(it){
        // Return to stash
        addToStash(it);
        bagLoadout[i]=null;
        renderHomebase();
      }
    };
    lg.appendChild(slot);
  }

  // â”€â”€ MARKET â”€â”€
  const ml=document.getElementById('market-list');
  ml.innerHTML='';
  // Market: wands + armors + boots + acc + tier1-2 crystals only
  const marketItems=ALL_ITEMS.filter(w=>
    w.type!=='crystal' || w.tier<=2
  );
  marketItems.forEach(w=>{
    const price=marketPrices[w.id]||w.basePrice;
    const trend=price>w.basePrice?'up':'down';
    const trendIcon=trend==='up'?'â–²':'â–¼';
    const inStash=stash.some(s=>s.id===w.id);
    const typeLabel=w.type==='armor'?'[é˜²]':w.type==='boots'?'[é‹]':w.type==='acc'?'[é¥°]':w.type==='crystal'?'[æ™¶]':'[æ–]';
    const typeClr=w.type==='crystal'?w.color:w.type==='armor'?'#94a3b8':w.type==='boots'?'#4ade80':w.type==='acc'?'#fbbf24':'#c084fc';
    const div=document.createElement('div');
    div.className='market-item';
    div.innerHTML=`
      <div class="mi-icon">${w.icon}</div>
      <div class="mi-info">
        <div class="mi-name">${w.name} <span style="font-size:6px;color:${typeClr}">${typeLabel}</span></div>
        <div class="mi-price">
          <span class="price-val">â—ˆ${price}</span>
          <span class="price-trend ${trend}">${trendIcon}</span>
          Â· ${w.desc||''}
        </div>
      </div>
      <div style="display:flex;flex-direction:column;gap:4px">
        <button class="mi-action mi-sell" ${inStash?'':'disabled'}
          onclick="sellItem('${w.id}',${price})">å–å‡º</button>
        <button class="mi-action mi-buy" ${gold>=price?'':'disabled'}
          onclick="buyItem('${w.id}',${price})">â—ˆ${price}</button>
      </div>
    `;
    ml.appendChild(div);
  });
}


function raidEquipClick(slot){
  // åœ¨raidä¸­ç‚¹å‡»è£…å¤‡æ§½ï¼šæœªæ¥åŠŸèƒ½
}

// homebase: è£…å¤‡æ§½ç‚¹å‡»åé€‰ä¸­ï¼Œå†ç‚¹ä»“åº“æ ¼å­æˆ–å–å‡º
function clickEquipSlot(type){
  if(selectedStorage!==null&&stash[selectedStorage]){
    const it=stash[selectedStorage];
    const isWand=!it.type;
    const itType=isWand?'weapon':it.type;
    if(itType===type||(type==='weapon'&&isWand)){
      if(equipSlots[type]) addToStash(equipSlots[type]);
      if(it.type==='crystal'){return;}
      equipSlots[type]=Object.assign({},it);
      stash.splice(selectedStorage,1);
      selectedStorage=null;
      updateLoadoutHint();
      renderHomebase();
    }
  } else {
    // é€‰ä¸­/å–æ¶ˆé€‰ä¸­è£…å¤‡æ§½
    selectedEquipSlot=(selectedEquipSlot===type)?null:type;
    selectedStorage=null;
    renderHomebase();
  }
}

function unequipSlot(type,e){
  if(e) e.stopPropagation();
  if(equipSlots[type]){addToStash(equipSlots[type]);equipSlots[type]=null;}
  selectedEquipSlot=null;
  renderHomebase();
}

function sellEquippedItem(type,e){
  if(e) e.stopPropagation();
  const it=equipSlots[type];
  if(!it)return;
  const price=Math.floor((marketPrices[it.id]||it.basePrice||20)*0.7);
  gold+=price;
  equipSlots[type]=null;
  selectedEquipSlot=null;
  renderHomebase();
}
function renderRaidEquipSlots(){
  const defs={
    weapon:{fallback:'âš”', label:'WEAPON', getItem:()=>player.equippedWeapon},
    armor: {fallback:'ğŸ›¡', label:'ARMOR',  getItem:()=>player.equippedArmor},
    boots: {fallback:'ğŸ‘¢', label:'BOOTS',  getItem:()=>player.equippedBoots},
    acc:   {fallback:'ğŸ’', label:'ACC',    getItem:()=>player.equippedAcc},
  };
  Object.entries(defs).forEach(([type,cfg])=>{
    const el=document.getElementById('req-'+type);
    if(!el)return;
    const item=cfg.getItem();
    if(item){
      const stat=(item.dmgMin?`DMG ${item.dmgMin}-${item.dmgMax} RNG ${item.range}`:'')
               +(item.def?`DEF ${item.def}`:'')
               +(item.spd?`SPD +${item.spd}`:'')
               +(item.maxHp?`HP +${item.maxHp}`:'');
      el.className='req-slot filled';
      el.innerHTML=`<span class="req-icon">${item.icon}</span><div class="req-info"><span class="req-label">${cfg.label}</span><span class="req-name">${item.name}</span><span class="req-stat">${stat}</span></div>`;
    } else {
      el.className='req-slot';
      el.innerHTML=`<span class="req-icon" style="opacity:0.25">${cfg.fallback}</span><div class="req-info"><span class="req-label" style="color:#2e2e3a">${cfg.label}</span><span class="req-name" style="color:#2a2a3a">â€” empty â€”</span></div>`;
    }
  });

  // å¼¹è¯æ§½
  const ammoEl=document.getElementById('raid-ammo-grid');
  if(!ammoEl)return;
  ammoEl.innerHTML='';
  const pool=player.ammoPool||[];
  const maxSlots=4;
  for(let i=0;i<maxSlots;i++){
    const slot=document.createElement('div');
    const entry=pool[i];
    if(entry&&entry.qty>0){
      slot.className='ammo-slot filled';
      slot.innerHTML=`<span class="ammo-icon">${entry.crystal.icon}</span><span class="ammo-qty">Ã—${entry.qty}</span><span class="ammo-name">${entry.crystal.name}</span>`;
    } else {
      slot.className='ammo-slot';
      slot.innerHTML=`<span class="ammo-icon" style="opacity:0.2">ğŸ’</span><span class="ammo-name" style="color:#2a2a3a">â€” ç©º â€”</span>`;
    }
    ammoEl.appendChild(slot);
  }
}
function updateLoadoutHint(){
  document.getElementById('loadout-hint').textContent=
    selectedStorage!==null?'â† é€‰æ‹©æ”¾ç½®ä½ç½®':'';
}

function clickEquipSlot(type){
  if(selectedStorage!==null&&stash[selectedStorage]){
    const it=stash[selectedStorage];
    const isWand=!it.type;
    const itType=isWand?'weapon':it.type;
    if(itType===type||(type==='weapon'&&isWand)){
      // Unequip current if any
      if(equipSlots[type]) addToStash(equipSlots[type]);
      if(it.type==='crystal'){return;} // crystals go to ammo slots
      equipSlots[type]=Object.assign({},it);
      stash.splice(selectedStorage,1);
      selectedStorage=null;
      updateLoadoutHint();
      renderHomebase();
    }
  } else {
    selectedEquipSlot=(selectedEquipSlot===type)?null:type;
    renderHomebase();
  }
}

function unequipSlot(type,e){
  e.stopPropagation();
  if(equipSlots[type]){addToStash(equipSlots[type]);equipSlots[type]=null;}
  renderHomebase();
}

function clickAmmoSlot(i){
  if(selectedStorage!==null&&stash[selectedStorage]){
    const it=stash[selectedStorage];
    if(it.type!=='crystal'){return;}
    if(ammoSlots[i]&&ammoSlots[i].crystal.id===it.id){
      // Stack
      ammoSlots[i].qty=Math.min(99,(ammoSlots[i].qty||0)+(it.qty||1));
      stash.splice(selectedStorage,1);
    } else if(!ammoSlots[i]){
      ammoSlots[i]={crystal:Object.assign({},it),qty:it.qty||1};
      stash.splice(selectedStorage,1);
    } else {
      // Swap
      addToStash(Object.assign({},ammoSlots[i].crystal,{qty:ammoSlots[i].qty}));
      ammoSlots[i]={crystal:Object.assign({},it),qty:it.qty||1};
      stash.splice(selectedStorage,1);
    }
    selectedStorage=null;
    updateLoadoutHint();
    renderHomebase();
  }
}

function clearAmmoSlot(i,e){
  e.stopPropagation();
  if(ammoSlots[i]){
    addToStash(Object.assign({},ammoSlots[i].crystal,{qty:ammoSlots[i].qty}));
    ammoSlots[i]=null;
  }
  renderHomebase();
}

function addToStash(it){
  // If crystal, try stacking
  if(it.type==='crystal'){
    const existing=stash.find(s=>s.id===it.id&&s.type==='crystal'&&(s.qty||1)<99);
    if(existing){existing.qty=Math.min(99,(existing.qty||1)+(it.qty||1));return;}
  }
  if(stash.length<20) stash.push(Object.assign({},it));
}

function sellItem(id,price){
  const idx=stash.findIndex(s=>s.id===id);
  if(idx<0){addLog('ä»“åº“ä¸­æ— æ­¤ç‰©å“','dmg');return;}
  stash.splice(idx,1);
  gold+=price;
  addLog(`å–å‡º +â—ˆ${price}`,'loot');
  renderHomebase();
}

function buyItem(id,price){
  if(gold<price){addLog('é‡‘å¸ä¸è¶³','dmg');return;}
  if(stash.length>=20){addLog('ä»“åº“å·²æ»¡','dmg');return;}
  const it=ALL_ITEMS.find(w=>w.id===id);
  if(!it)return;
  const item=Object.assign({},it);
  if(item.type==='crystal') item.qty=10;
  addToStash(item);
  gold-=price;
  addLog(`è´­ä¹° ${it.name}`,'info');
  renderHomebase();
}


// Toggle side panels
let activePanel = null;
function togglePanel(name){
  const panels = ['equip','bag'];
  // If clicking active panel, close it
  if(activePanel === name){
    document.getElementById('panel-'+name).style.display='none';
    document.getElementById('tab-'+name).classList.remove('active');
    activePanel = null;
    return;
  }
  // Close all panels first
  panels.forEach(p=>{
    document.getElementById('panel-'+p).style.display='none';
    document.getElementById('tab-'+p).classList.remove('active');
  });
  // Open requested
  document.getElementById('panel-'+name).style.display='block';
  document.getElementById('tab-'+name).classList.add('active');
  activePanel = name;
  if(name==='bag') updateInvGrid();
  if(name==='equip') renderRaidEquipSlots();
}
function showLootPanel(){ document.getElementById('raid-loot').style.display='block'; }
function hideLootPanel(){ document.getElementById('raid-loot').style.display='none'; }
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RAID START
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startRaid(){
  genMap();
  initPlayer();
  spawnChests();
  spawnEnemies();
  projectiles=[];particles=[];droppedWands=[];
  pickupTarget=null;pickupProgress=0;selectedInvIdx=null;
  frames=0;gameState='playing';

  document.getElementById('homebase').style.display='none';
  document.getElementById('hud').style.display='block';
  document.getElementById('death-screen').style.display='none';
  document.getElementById('extract-screen').style.display='none';
  document.getElementById('gold-display').textContent=`â—ˆ ${gold}`;

  if(isTouchDevice()){
    document.getElementById('joystick-base').style.display='block';
    document.getElementById('touch-btns').style.display='flex';
  }

  activePanel=null;
  ['equip','bag'].forEach(p=>{const el=document.getElementById('panel-'+p);if(el)el.style.display='none';const t=document.getElementById('tab-'+p);if(t)t.classList.remove('active');});
  hideLootPanel();
  updateInvGrid();
  updateAmmoHud();
  buildMap3();
  buildChestMeshes3();
  initCamControls3();
  // å»ºæ”»å‡»èŒƒå›´åœ†åœˆ
  const _w = equipSlots.weapon;
  buildRangeRing3(_w ? _w.range : 40);
  // ç«‹åˆ»æŠŠç›¸æœºå®šä½åˆ°ç©å®¶å‡ºç”Ÿç‚¹ï¼Œé¿å…ç¬¬ä¸€å¸§çœ‹åˆ°åŸç‚¹
  const _initAngle = camAngle3 * Math.PI / 180;
  const _initDist  = camHeight3 / Math.tan(Math.max(5, camAngle3) * Math.PI / 180);
  camera3.position.set(player.wx, camHeight3, player.wy + _initDist);
  camera3.lookAt(player.wx, 0, player.wy);
  addLog('è¿›å…¥ FORSAKEN SANCTUM','imp');
  addLog('æœåˆ®Â·æ’¤ç¦»Â·å‹¿æ­»','info');
  // increment raids counter async
  if(currentUser&&currentSlot){
    sb.from('saves').select('raids').eq('user_id',currentUser.id).eq('slot',currentSlot).single()
      .then(({data})=>{
        const r=(data?.raids||0)+1;
        sb.from('saves').update({raids:r}).eq('user_id',currentUser.id).eq('slot',currentSlot);
      });
  }
  selectedStorage=null;selectedLoadout=null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW â€” ISOMETRIC RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// æ—§2D canvas å·²æ›¿æ¢ä¸º Three.jsï¼Œä»…ä¿ç•™å°åœ°å›¾canvas
const mmCanvas=document.getElementById('mm-canvas');
const mmCtx=mmCanvas.getContext('2d');

// â”€â”€ BATTLE LOG â”€â”€
const logEl=document.getElementById('log');
function addLog(msg,cls=''){
  const d=document.createElement('div');
  d.className='log-line'+(cls?' '+cls:'');
  d.textContent=msg;
  logEl.prepend(d);
  while(logEl.children.length>8)logEl.removeChild(logEl.lastChild);
}

// â”€â”€ AMMO HUD â”€â”€
function updateAmmoHud(){
  const el=document.getElementById('ammo-hud');
  if(!el)return;
  if(!player||!player.ammoPool||player.ammoPool.length===0){
    el.textContent='';return;
  }
  el.textContent=player.ammoPool.map(a=>`${a.crystal.icon}Ã—${a.qty}`).join(' ');
}

// â”€â”€ UTILITIES â”€â”€
function dist(ax,ay,bx,by){return Math.sqrt((ax-bx)**2+(ay-by)**2);}
function normalize(dx,dy){const d=Math.sqrt(dx*dx+dy*dy)||1;return[dx/d,dy/d];}

// 2D camera (used by loop for entity position tracking)
function updateCamera(){
  cam.x=player.wx-W/2;cam.y=player.wy-H/2;
  cam.x=Math.max(0,Math.min(MAP_W-W,cam.x));
  cam.y=Math.max(0,Math.min(MAP_H-H,cam.y));
}

// â”€â”€ CYCLE WEAPON â”€â”€
function cycleWeapon(){
  if(!player||player.inventory.length===0)return;
  player.equippedIdx=((player.equippedIdx||0)+1)%player.inventory.length;
  const entry=player.inventory[player.equippedIdx];
  const it=entry?.item||entry?.wand;
  if(it) addLog(`è£…å¤‡: ${it.name}`,'info');
  updateInvGrid();
}

// â”€â”€ SCALE APP â”€â”€
function scaleApp(){
  const app=document.getElementById('app');
  const sc=Math.min(window.innerWidth/900,window.innerHeight/600);
  app.style.transform=`scale(${sc})`;
  app.style.left=((window.innerWidth-900*sc)/2)+'px';
  app.style.top=((window.innerHeight-600*sc)/2)+'px';
}
scaleApp();
window.addEventListener('resize',scaleApp);

// â”€â”€ KEYBOARD INPUT â”€â”€
const keys={};
document.addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true;
  if(e.key.toLowerCase()==='f')tryStartPickup();
  if(e.key.toLowerCase()==='e')cycleWeapon();
  if(e.key===' '){e.preventDefault();}
});
document.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// click canvas for pickup
document.getElementById('three-canvas').addEventListener('click',e=>{
  if(gameState!=='playing')return;
  tryStartPickup();
});

// â”€â”€ TOUCH JOYSTICK â”€â”€
function initJoystick(){
  const base=document.getElementById('joystick-base');
  const knob=document.getElementById('joystick-knob');
  function center(){
    const r=base.getBoundingClientRect();
    const ar=document.getElementById('app').getBoundingClientRect();
    const sc=ar.width/900;
    return{x:(r.left+r.width/2-ar.left)/sc,y:(r.top+r.height/2-ar.top)/sc};
  }
  base.addEventListener('touchstart',e=>{e.preventDefault();joystickActive=true;joystickOrigin=center();},{passive:false});
  base.addEventListener('touchmove',e=>{
    e.preventDefault();if(!joystickActive)return;
    const t=e.touches[0];
    const ar=document.getElementById('app').getBoundingClientRect();
    const sc=ar.width/900;
    let dx=(t.clientX-ar.left)/sc-joystickOrigin.x;
    let dy=(t.clientY-ar.top)/sc-joystickOrigin.y;
    const d=Math.sqrt(dx*dx+dy*dy);
    if(d>JOYSTICK_MAX){dx=dx/d*JOYSTICK_MAX;dy=dy/d*JOYSTICK_MAX;}
    joystickDelta={x:dx,y:dy};
    knob.style.transform=`translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`;
  },{passive:false});
  const end=()=>{joystickActive=false;joystickDelta={x:0,y:0};knob.style.transform='translate(-50%,-50%)';};
  base.addEventListener('touchend',end,{passive:false});
  base.addEventListener('touchcancel',end,{passive:false});
}

function getTouchMove(){
  if(!joystickActive)return[0,0];
  return[joystickDelta.x/JOYSTICK_MAX,joystickDelta.y/JOYSTICK_MAX];
}
// ctx stubï¼ˆéƒ¨åˆ†æ—§ä»£ç å¼•ç”¨ï¼Œé˜²æ­¢æŠ¥é”™ï¼‰
const ctx={ clearRect:()=>{}, fillRect:()=>{}, createRadialGradient:()=>({addColorStop:()=>{}}),
  save:()=>{}, restore:()=>{}, globalAlpha:1, fillStyle:'', beginPath:()=>{},
  arc:()=>{}, fill:()=>{}, stroke:()=>{}, strokeStyle:'', lineWidth:1 };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THREE.JS æ¸²æŸ“å¼•æ“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ å¸¸é‡ â”€â”€
const U      = TILE;        // ä¸–ç•Œå•ä½ = åŸæ¥çš„TILEåƒç´ 
const PLAT_H = 1.0;         // å¹³å°é«˜åº¦
const WALL_H = 2.5;         // å¢™é«˜åº¦
const SLAB   = 0.2;         // åœ°é¢æ¿åšåº¦
const PX_TO_U = 1;          // åƒç´ åˆ°ä¸–ç•Œå•ä½1:1ï¼ˆlaterå¯è°ƒæ•´ï¼‰

// â”€â”€ Renderer â”€â”€
const threeCanvas = document.getElementById('three-canvas');
const renderer3 = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true });
renderer3.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer3.setSize(W, H);
renderer3.shadowMap.enabled = true;
renderer3.shadowMap.type = THREE.PCFSoftShadowMap;

const scene3 = new THREE.Scene();
scene3.background = new THREE.Color(0x0a0e14);
scene3.fog = new THREE.Fog(0x0a0e14, MAP_W * 0.6, MAP_W * 1.1);

// â”€â”€ æ­£äº¤ç›¸æœº â”€â”€
let camHeight3  = 800;
let camAngle3   = 45;   // ä¿¯è§’ï¼ˆåº¦ï¼‰
let orthoSize3  = 420;
const ASPECT3   = W / H;

// é€è§†ç›¸æœºï¼šæœ‰è¿‘å¤§è¿œå°ï¼Œé«˜å°æ‰æœ‰çœŸ3Dç«‹ä½“æ„Ÿ
const camera3 = new THREE.PerspectiveCamera(45, ASPECT3, 1, 12000);

function updateFrustum3() {
  // é€è§†ç›¸æœºç”¨ FOV å’Œ zoom æ§åˆ¶è§†é‡å¤§å°ï¼ˆå¯¹åº”åŸæ¥çš„ orthoSize3 sliderï¼‰
  camera3.fov = Math.max(10, Math.min(90, 45 * (420 / orthoSize3)));
  camera3.aspect = ASPECT3;
  camera3.updateProjectionMatrix();
}
updateFrustum3();

// â”€â”€ å…‰æº â”€â”€
scene3.add(new THREE.AmbientLight(0x1a2030, 3.5));  // åå†·è“ï¼ŒæŸ”å’Œ

const sun3 = new THREE.DirectionalLight(0xc8b89a, 1.8);  // æš–è‰²ä½†ä¸åˆºçœ¼
sun3.castShadow = true;
sun3.shadow.mapSize.set(2048, 2048);
sun3.shadow.camera.left = sun3.shadow.camera.bottom = -MAP_W * 0.7;
sun3.shadow.camera.right = sun3.shadow.camera.top   =  MAP_W * 0.7;
sun3.shadow.camera.far   = 3000;
sun3.shadow.bias = -0.001;
scene3.add(sun3);

const sunTarget3 = new THREE.Object3D();
scene3.add(sunTarget3);
sun3.target = sunTarget3;

const fill3 = new THREE.DirectionalLight(0x1a2844, 0.5);  // æ·±è“è¡¥å…‰
fill3.position.set(-MAP_W * 0.3, MAP_W * 0.3, MAP_W * 0.5);
scene3.add(fill3);

// â”€â”€ æè´¨ â”€â”€
const MAT3 = {
  floor:    new THREE.MeshLambertMaterial({ color: 0x1c2030 }),   // æ·±è“ç°åœ°æ¿
  platform: new THREE.MeshLambertMaterial({ color: 0x1e2a38 }),
  ramp:     new THREE.MeshLambertMaterial({ color: 0x1a2432, side: THREE.DoubleSide }),
  wall:     new THREE.MeshLambertMaterial({ color: 0x0d1220 }),   // å‡ ä¹é»‘çš„å¢™
  wallTop:  new THREE.MeshLambertMaterial({ color: 0x151c2a }),
  extract:  new THREE.MeshBasicMaterial({ color: 0x4ade80, transparent: true, opacity: 0.6, side: THREE.DoubleSide }),
  extractPillar: new THREE.MeshLambertMaterial({ color: 0x4ade80, transparent: true, opacity: 0.15, emissive: 0x1a5c30 }),
};

// â”€â”€ æ¥”å½¢ä¸‰æ£±æŸ±ï¼ˆæ–œå¡ï¼‰â”€â”€
// dir: 'N'ä½è¾¹æœåŒ—(ä½è¾¹-Z), 'S'ä½è¾¹æœå—(+Z), 'E'ä½è¾¹æœä¸œ(+X), 'W'ä½è¾¹æœè¥¿(-X)
function makeWedgeGeo(dir) {
  const h = PLAT_H, u = U;
  // 6ä¸ªé¡¶ç‚¹ï¼šåº•é¢4è§’ + é«˜è¾¹2è§’
  let verts;
  if (dir === 'N') { // åŒ—ä¾§ä½ï¼Œå—ä¾§é«˜
    verts = [
      -u/2,0, u/2,  u/2,0, u/2,  -u/2,0,-u/2,  u/2,0,-u/2,  // åº•é¢
      -u/2,h, u/2,  u/2,h, u/2,  // å—ä¾§é«˜è¾¹
    ];
  } else if (dir === 'S') { // å—ä¾§ä½ï¼ŒåŒ—ä¾§é«˜
    verts = [
      -u/2,0, u/2,  u/2,0, u/2,  -u/2,0,-u/2,  u/2,0,-u/2,
      -u/2,h,-u/2,  u/2,h,-u/2,  // åŒ—ä¾§é«˜è¾¹
    ];
  } else if (dir === 'E') { // ä¸œä¾§ä½ï¼Œè¥¿ä¾§é«˜
    verts = [
      -u/2,0, u/2,  u/2,0, u/2,  -u/2,0,-u/2,  u/2,0,-u/2,
      -u/2,h, u/2,  -u/2,h,-u/2, // è¥¿ä¾§é«˜è¾¹
    ];
  } else { // 'W': è¥¿ä¾§ä½ï¼Œä¸œä¾§é«˜
    verts = [
      -u/2,0, u/2,  u/2,0, u/2,  -u/2,0,-u/2,  u/2,0,-u/2,
      u/2,h, u/2,   u/2,h,-u/2,  // ä¸œä¾§é«˜è¾¹
    ];
  }

  // ä¸‰è§’é¢ç´¢å¼•ï¼ˆé¡¶ç‚¹: 0SW 1SE 2NW 3NE 4high_a 5high_bï¼‰
  const tris = {
    N: [[0,1,4],[1,5,4], [2,4,3],[3,4,5], [0,4,2], [1,3,5], [0,2,1],[1,2,3]],
    S: [[2,4,3],[3,4,5], [0,1,4],[1,5,4], [2,0,4], [3,5,1], [0,2,1],[1,2,3]],
    E: [[0,4,2],[2,4,5], [1,0,4],[0,5,4], [0,1,2],[1,3,2], [0,2,4],[1,5,3]],
    W: [[1,4,3],[3,4,5], [0,4,1],[0,5,4], [0,1,2],[1,3,2], [1,4,0],[3,5,2]],
  };

  const faces = tris[dir];
  const positions = [], normals = [];
  for (const [a,b,c] of faces) {
    const ax=verts[a*3],ay=verts[a*3+1],az=verts[a*3+2];
    const bx=verts[b*3],by=verts[b*3+1],bz=verts[b*3+2];
    const cx=verts[c*3],cy=verts[c*3+1],cz=verts[c*3+2];
    positions.push(ax,ay,az, bx,by,bz, cx,cy,cz);
    const ux_=bx-ax, uy_=by-ay, uz_=bz-az;
    const vx_=cx-ax, vy_=cy-ay, vz_=cz-az;
    const nx=uy_*vz_-uz_*vy_, ny=uz_*vx_-ux_*vz_, nz=ux_*vy_-uy_*vx_;
    const nl=Math.sqrt(nx*nx+ny*ny+nz*nz)||1;
    normals.push(nx/nl,ny/nl,nz/nl, nx/nl,ny/nl,nz/nl, nx/nl,ny/nl,nz/nl);
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geo.setAttribute('normal',   new THREE.Float32BufferAttribute(normals, 3));
  return geo;
}

// â”€â”€ æ„å»ºåœ°å›¾åœºæ™¯ â”€â”€
let mapMeshes3 = [];  // æ‰€æœ‰åœ°å›¾meshï¼ŒstartRaidæ—¶é‡å»º

function buildMap3() {
  // æ¸…é™¤æ—§mesh
  for (const m of mapMeshes3) scene3.remove(m);
  mapMeshes3 = [];

  function add(m) { m.receiveShadow = true; m.castShadow = true; scene3.add(m); mapMeshes3.push(m); }

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const t   = tileMap[r][c];
      const elv = elevMap[r][c] || 0;
      const sl  = slopeMap[r][c];
      const cx  = c * U + U/2;
      const cz  = r * U + U/2;

      if (t === 1) {
        // å¢™
        const m = new THREE.Mesh(new THREE.BoxGeometry(U, WALL_H, U), MAT3.wall);
        m.position.set(cx, WALL_H/2, cz);
        add(m);
        const top = new THREE.Mesh(new THREE.BoxGeometry(U+0.1, 0.15, U+0.1), MAT3.wallTop);
        top.position.set(cx, WALL_H + 0.075, cz);
        add(top);

      } else if (sl === 'ramp') {
        // æ–œå¡ï¼šåˆ¤æ–­å¡å‘ï¼ˆçœ‹ç›¸é‚»æ ¼é«˜åº¦å·®ï¼‰
        const hN = r>0        ? (heightMap[r-1]?.[c]||0) : 0;
        const hS = r<ROWS-1   ? (heightMap[r+1]?.[c]||0) : 0;
        const hW = c>0        ? (heightMap[r]?.[c-1]||0) : 0;
        const hE = c<COLS-1   ? (heightMap[r]?.[c+1]||0) : 0;
        // é«˜è¾¹æ–¹å‘ = å“ªè¾¹é‚»å±…æ›´é«˜
        let dir = 'N';
        const maxD = Math.max(hN,hS,hE,hW);
        if      (hN === maxD) dir = 'S';  // åŒ—è¾¹é«˜ â†’ ä½è¾¹æœå—
        else if (hS === maxD) dir = 'N';  // å—è¾¹é«˜ â†’ ä½è¾¹æœåŒ—
        else if (hE === maxD) dir = 'W';  // ä¸œè¾¹é«˜ â†’ ä½è¾¹æœè¥¿
        else                  dir = 'E';  // è¥¿è¾¹é«˜ â†’ ä½è¾¹æœä¸œ

        // åº•é¢åœ°æ¿
        const base = new THREE.Mesh(new THREE.BoxGeometry(U, SLAB, U), MAT3.floor);
        base.position.set(cx, -SLAB/2, cz);
        add(base);
        // æ¥”å½¢
        const wedge = new THREE.Mesh(makeWedgeGeo(dir), MAT3.ramp);
        wedge.position.set(cx, 0, cz);
        add(wedge);

      } else if (elv >= 1) {
        // å¹³å°
        const base = new THREE.Mesh(new THREE.BoxGeometry(U, SLAB, U), MAT3.floor);
        base.position.set(cx, -SLAB/2, cz);
        add(base);
        const plat = new THREE.Mesh(new THREE.BoxGeometry(U, PLAT_H, U), MAT3.platform);
        plat.position.set(cx, PLAT_H/2, cz);
        add(plat);

      } else if (elv >= 2) {
        // ç‹¬ç«‹å¹³å°åŒºåŸŸï¼šç”± buildPlatform3D è´Ÿè´£æ¸²æŸ“ï¼Œtileå¾ªç¯è·³è¿‡
        continue;
      } else {
        // æ™®é€šåœ°é¢
        const m = new THREE.Mesh(new THREE.BoxGeometry(U, SLAB, U), MAT3.floor);
        m.position.set(cx, -SLAB/2, cz);
        add(m);
      }
    }
  }


  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ç‹¬ç«‹çœŸ 3D é«˜å°ç‰©ä»¶ï¼ˆå®å¿ƒå¹³å° + å››é¢å®å¿ƒæ¥”å½¢æ–œå¡ï¼‰
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function buildPlatform3D(){
    const PX  = MAP_W * 0.35;      // å¹³å°ä¸­å¿ƒ X
    const PZ  = MAP_H * 0.38;      // å¹³å°ä¸­å¿ƒ Z
    const PW  = U * 8;             // å¹³å°å®½ X
    const PD  = U * 6;             // å¹³å°æ·± Z
    const PH  = U * 0.9;           // å¹³å°é«˜åº¦ï¼ˆâ‰ˆ36å•ä½ â‰ˆ 2å€è§’è‰²èº«é«˜ï¼Œæ¸…æ™°å¯è§ï¼‰
    const RW  = U * 2;             // æ–œå¡æ°´å¹³å»¶ä¼¸è·ç¦»ï¼ˆ2æ ¼ï¼‰

    const matTop  = new THREE.MeshLambertMaterial({ color: 0x243c54 });
    const matSide = new THREE.MeshLambertMaterial({ color: 0x162030 });
    const matRamp = new THREE.MeshLambertMaterial({ color: 0x1c3040, side: THREE.DoubleSide });

    function addP(m){ m.receiveShadow=true; m.castShadow=true; scene3.add(m); mapMeshes3.push(m); }

    // â”€â”€ ä¸­å¤®å¹³å°ä¸»ä½“ï¼ˆå®å¿ƒ Boxï¼Œå¤šæè´¨ï¼šé¡¶é¢äº®ï¼Œä¾§é¢æš—ï¼‰â”€â”€
    const platGeo = new THREE.BoxGeometry(PW, PH, PD);
    // three.js BoxGeometry é¢åºï¼š+X -X +Y -Y +Z -Z
    const plat = new THREE.Mesh(platGeo, [matSide, matSide, matTop, matSide, matSide, matSide]);
    plat.position.set(PX, PH * 0.5, PZ);
    addP(plat);

    // â”€â”€ å®å¿ƒæ¥”å½¢æ–œå¡ç”Ÿæˆå‡½æ•° â”€â”€
    // æ¥”å½¢æ˜¯äº”é¢ä½“ï¼šæ–œé¢ + åº•é¢ + ä¸¤ä¾§ä¸‰è§’é¢ + é«˜ä¾§é¢ + ä½ä¾§é¢ï¼ˆé«˜åº¦0ï¼‰
    // å±€éƒ¨åæ ‡ï¼šæ²¿ +Z æ–¹å‘ä»å¹³å°è¾¹ç¼˜å¾€å¤–å»¶ä¼¸ RW
    //   åº•è¾¹ï¼ˆz=0ï¼‰é«˜åº¦ y=PHï¼ˆä¸å¹³å°é¡¶é¢é½å¹³ï¼‰
    //   å¤–è¾¹ï¼ˆz=RWï¼‰é«˜åº¦ y=0ï¼ˆè½åˆ°åœ°é¢ï¼‰
    function makeWedge(cx, cz, faceW, rotY) {
      const hw = faceW / 2;
      // 8ä¸ªé¡¶ç‚¹ï¼š
      // å†…è¾¹ï¼ˆz=0ï¼‰ï¼šåº•éƒ¨ y=0ï¼Œé¡¶éƒ¨ y=PH
      // å¤–è¾¹ï¼ˆz=RWï¼‰ï¼šåªæœ‰ y=0ï¼ˆæ¥”å½¢å¤–æ²¿è´´åœ°ï¼‰
      //
      //  é¡¶ç‚¹å¸ƒå±€ï¼ˆå±€éƒ¨ç©ºé—´ï¼Œæ—‹è½¬å‰ï¼‰ï¼š
      //  0: (-hw, 0,   0)   å†…åº•å·¦
      //  1: ( hw, 0,   0)   å†…åº•å³
      //  2: (-hw, PH,  0)   å†…é¡¶å·¦  â† ä¸å¹³å°é¡¶é¢é½å¹³
      //  3: ( hw, PH,  0)   å†…é¡¶å³
      //  4: (-hw, 0,  RW)   å¤–åº•å·¦  â† è´´åœ°
      //  5: ( hw, 0,  RW)   å¤–åº•å³

      const pos = new Float32Array([
        -hw, 0,   0,   // 0
         hw, 0,   0,   // 1
        -hw, PH,  0,   // 2
         hw, PH,  0,   // 3
        -hw, 0,  RW,   // 4
         hw, 0,  RW,   // 5
      ]);

      // é¢ï¼ˆé€†æ—¶é’ˆ = æ­£é¢æœå¤–ï¼‰ï¼š
      // æ–œé¢ï¼ˆå¡é¢ï¼‰ï¼š2,3,5,4  â†’ ä¸¤ä¸ªä¸‰è§’
      // åº•é¢ï¼š0,4,5,1          â†’ ä¸¤ä¸ªä¸‰è§’
      // é«˜ä¾§é¢ï¼ˆå†…ç«–é¢ï¼‰ï¼š0,1,3,2 â†’ ä¸¤ä¸ªä¸‰è§’
      // å·¦ä¸‰è§’ä¾§é¢ï¼š0,2,4
      // å³ä¸‰è§’ä¾§é¢ï¼š1,5,3
      const idx = new Uint16Array([
        2,3,5,  2,5,4,   // æ–œé¢
        0,4,5,  0,5,1,   // åº•é¢
        0,1,3,  0,3,2,   // å†…ç«–é¢
        0,2,4,           // å·¦ä¸‰è§’
        1,5,3,           // å³ä¸‰è§’
      ]);

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.setIndex(new THREE.BufferAttribute(idx, 1));
      geo.computeVertexNormals();

      const mesh = new THREE.Mesh(geo, matRamp);
      mesh.rotation.y = rotY;
      mesh.position.set(cx, 0, cz);
      addP(mesh);
    }

    // å››é¢æ–œå¡ï¼šä»å¹³å°å„è¾¹æ²¿ rotY æ–¹å‘å‘å¤–å»¶ä¼¸
    // rotY=0      â†’ +Z æ–¹å‘å»¶ä¼¸ï¼ˆå—é¢æ–œå¡ï¼Œå¹³å°å—è¾¹ï¼‰
    // rotY=PI     â†’ -Z æ–¹å‘å»¶ä¼¸ï¼ˆåŒ—é¢æ–œå¡ï¼‰
    // rotY=-PI/2  â†’ +X æ–¹å‘å»¶ä¼¸ï¼ˆä¸œé¢æ–œå¡ï¼‰
    // rotY=+PI/2  â†’ -X æ–¹å‘å»¶ä¼¸ï¼ˆè¥¿é¢æ–œå¡ï¼‰
    makeWedge(PX,       PZ + PD/2,  PW, 0);            // å—
    makeWedge(PX,       PZ - PD/2,  PW, Math.PI);      // åŒ—
    makeWedge(PX + PW/2, PZ,        PD, -Math.PI/2);   // ä¸œ
    makeWedge(PX - PW/2, PZ,        PD,  Math.PI/2);   // è¥¿

    // elevMap å·²åœ¨ genMap() ä¸­å†™å…¥ï¼Œæ­¤å¤„æ— éœ€é‡å¤
  })();
  // æ’¤ç¦»ç‚¹
  const ex3 = extractPoint.wx + U/2, ez3 = extractPoint.wy + U/2;
  const ering = new THREE.Mesh(new THREE.RingGeometry(U*0.4, U*0.65, 32), MAT3.extract);
  ering.rotation.x = -Math.PI/2;
  ering.position.set(ex3, 0.03, ez3);
  scene3.add(ering); mapMeshes3.push(ering);
  const epillar = new THREE.Mesh(new THREE.CylinderGeometry(U*0.1, U*0.4, U*1.5, 8), MAT3.extractPillar);
  epillar.position.set(ex3, U*0.75, ez3);
  scene3.add(epillar); mapMeshes3.push(epillar);
}

// â”€â”€ å®ä½“ 3D Mesh ç®¡ç† â”€â”€
// player mesh
const playerMesh3 = new THREE.Group();
{
  const mat = new THREE.MeshLambertMaterial({ color: 0x5b8dd9, emissive: 0x0a1428 });
  const body = new THREE.Mesh(new THREE.CylinderGeometry(U*0.14, U*0.16, U*0.44, 12), mat);
  body.position.y = U*0.22; body.castShadow = true; playerMesh3.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(U*0.11, 12, 8), mat);
  head.position.y = U*0.5; head.castShadow = true; playerMesh3.add(head);
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(U*0.17, U*0.23, 20),
    new THREE.MeshBasicMaterial({ color:0x3a88ff, transparent:true, opacity:0.45, side:THREE.DoubleSide })
  );
  ring.rotation.x = -Math.PI/2; ring.position.y = 0.02; playerMesh3.add(ring);
}
scene3.add(playerMesh3);

// enemy meshes pool
const enemyMeshPool3 = [];
function getEnemyMesh3(color) {
  const mat = new THREE.MeshLambertMaterial({ color: color||0xc0392b, emissive: 0x0e0404 });
  const g = new THREE.Group();
  const b = new THREE.Mesh(new THREE.CylinderGeometry(U*0.13, U*0.15, U*0.4, 10), mat);
  b.position.y = U*0.2; b.castShadow = true; g.add(b);
  const h = new THREE.Mesh(new THREE.SphereGeometry(U*0.1, 10, 7), mat);
  h.position.y = U*0.47; h.castShadow = true; g.add(h);
  g.visible = false;
  scene3.add(g);
  return g;
}
// é¢„å»ºæ± 
for (let i = 0; i < 30; i++) enemyMeshPool3.push(getEnemyMesh3(0xff3a3a));

// chest meshes
const chestMeshes3 = [];

// dropped item meshes
const droppedMeshes3 = [];

// projectile meshes - æ¯ç§é¢œè‰²ç‹¬ç«‹æè´¨ï¼Œå°ºå¯¸åŠ å¤§
const projMeshes3 = [];
const projGeo3 = new THREE.SphereGeometry(U * 0.35, 8, 6);  // 14ä¸ªä¸–ç•Œå•ä½ï¼Œå¯è§
const projMatCache3 = {};
function getProjMat3(color) {
  if (!projMatCache3[color]) {
    projMatCache3[color] = new THREE.MeshBasicMaterial({
      color: new THREE.Color(color || '#ffdd44'),
      transparent: true, opacity: 0.92
    });
  }
  return projMatCache3[color];
}

// particle meshes (ç®€å•ç”¨ç‚¹ï¼‰
const partMeshes3 = [];
const partMat3 = new THREE.MeshBasicMaterial({ color: 0xff8844 });
const partGeo3 = new THREE.SphereGeometry(U * 0.04, 4, 3);

// æ ¼çº¿ï¼ˆåœ°é¢è£…é¥°ï¼‰
{
  const g = new THREE.EdgesGeometry(
    new THREE.PlaneGeometry(MAP_W, MAP_H, COLS, ROWS)
  );
  const l = new THREE.LineSegments(g, new THREE.LineBasicMaterial({
    color: 0x2a3040, transparent: true, opacity: 0.08
  }));
  l.rotation.x = -Math.PI / 2;
  l.position.set(MAP_W/2, 0.01, MAP_H/2);
  scene3.add(l);
}

// â”€â”€ è·å–ä¸–ç•Œåæ ‡å¯¹åº”çš„3Dé«˜åº¦ â”€â”€
function getWorldY3(wx, wy) {
  const c = wx / TILE, r = wy / TILE;
  const ic = Math.floor(c), ir = Math.floor(r);
  const fc = c - ic, fr = r - ir;
  function gh(rr, cc) {
    if (rr<0||rr>=ROWS||cc<0||cc>=COLS) return 0;
    const h = heightMap[rr]?.[cc] || 0;
    return h * PLAT_H;
  }
  return gh(ir,ic)*(1-fc)*(1-fr) + gh(ir,ic+1)*fc*(1-fr)
       + gh(ir+1,ic)*(1-fc)*fr   + gh(ir+1,ic+1)*fc*fr;
}

// â”€â”€ è¡€æ¡ spriteï¼ˆæ¯ä¸ªæ•Œäººç‹¬ç«‹ canvasï¼‰â”€â”€
const hpBarSprites3 = [];

function makeHpBarSprite3() {
  const cv = document.createElement('canvas');
  cv.width = 64; cv.height = 10;
  const ctx = cv.getContext('2d');
  const tex = new THREE.CanvasTexture(cv);
  const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, sizeAttenuation: true });
  const sp  = new THREE.Sprite(mat);
  sp.scale.set(U*1.4, U*0.22, 1);
  scene3.add(sp);
  return { sprite: sp, tex, cv, ctx };
}

function updateHpBar3(bar, pct) {
  const { ctx, cv, tex } = bar;
  ctx.clearRect(0, 0, 64, 10);
  ctx.fillStyle = '#1a0a0a';
  ctx.fillRect(0, 0, 64, 10);
  ctx.fillStyle = pct > 0.6 ? '#4ade80' : pct > 0.3 ? '#fbbf24' : '#f87171';
  ctx.fillRect(1, 1, Math.round(62 * pct), 8);
  tex.needsUpdate = true;
}

// â”€â”€ æ”»å‡»èŒƒå›´åœ†åœˆ â”€â”€
let rangeRing3 = null;
function buildRangeRing3(radius) {
  if (rangeRing3) scene3.remove(rangeRing3);
  const segs = 64;
  const pts = [];
  for (let i = 0; i <= segs; i++) {
    const a = (i / segs) * Math.PI * 2;
    pts.push(new THREE.Vector3(Math.cos(a)*radius, 0.1, Math.sin(a)*radius));
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({ color: 0xd97706, transparent: true, opacity: 0.5 });
  rangeRing3 = new THREE.Line(geo, mat);
  scene3.add(rangeRing3);
}

// â”€â”€ åŒæ­¥å®ä½“Meshåˆ°æ¸¸æˆçŠ¶æ€ â”€â”€
let prevEnemyCount3 = 0;

function syncEntities3() {
  // Player
  const py3 = getWorldY3(player.wx, player.wy);
  playerMesh3.position.x = player.wx;
  playerMesh3.position.z = player.wy;
  playerMesh3.position.y += (py3 - playerMesh3.position.y) * 0.25;

  // æ”»å‡»èŒƒå›´åœ†åœˆè·Ÿéšç©å®¶
  if (rangeRing3) {
    rangeRing3.position.x = player.wx;
    rangeRing3.position.z = player.wy;
    rangeRing3.position.y = 0.1;
  }

  // Enemies + HP bars
  for (let i = 0; i < enemyMeshPool3.length; i++) {
    const m = enemyMeshPool3[i];
    const e = enemies[i];
    if (!e) {
      m.visible = false;
      if (hpBarSprites3[i]) hpBarSprites3[i].sprite.visible = false;
      continue;
    }
    m.visible = true;
    const ey3 = getWorldY3(e.wx, e.wy);
    m.position.x = e.wx;
    m.position.z = e.wy;
    m.position.y += (ey3 - m.position.y) * 0.2;

    // é¢œè‰²åŒæ­¥
    const mat = m.children[0]?.material;
    if (mat && mat.color) {
      const col = new THREE.Color(e.color || '#ff3a3a');
      if (!mat.color.equals(col)) mat.color.set(col);
    }

    // è¡€æ¡
    if (!hpBarSprites3[i]) hpBarSprites3[i] = makeHpBarSprite3();
    const bar = hpBarSprites3[i];
    updateHpBar3(bar, Math.max(0, e.hp / e.maxHp));
    bar.sprite.visible = true;
    bar.sprite.position.set(e.wx, m.position.y + U*0.75, e.wy);
  }

  // Chests - æ¯ä¸ªç®±å­å¯¹åº”2ä¸ªmeshï¼ˆbox + pillarï¼‰
  for (let i = 0; i < chests.length; i++) {
    const ch = chests[i];
    const mBox    = chestMeshes3[i*2];
    const mPillar = chestMeshes3[i*2+1];
    const vis = !ch.opened;
    if (mBox)    mBox.visible    = vis;
    if (mPillar) mPillar.visible = vis;
  }

  // Projectiles
  for (let i = 0; i < 60; i++) {
    const p = projectiles[i];
    if (!p) {
      if (projMeshes3[i]) projMeshes3[i].visible = false;
      continue;
    }
    if (!projMeshes3[i]) {
      const m = new THREE.Mesh(projGeo3, getProjMat3(p.color));
      m.visible = false;
      scene3.add(m);
      projMeshes3[i] = m;
    }
    const m = projMeshes3[i];
    m.visible = true;
    m.material = getProjMat3(p.color);
    m.position.set(p.wx, U * 0.35, p.wy);  // å›ºå®šé£è¡Œé«˜åº¦ï¼Œä¸è´´åœ°
  }
}

// â”€â”€ æ„å»ºåˆå§‹chest mesh â”€â”€
function buildChestMeshes3() {
  for (const m of chestMeshes3) scene3.remove(m);
  chestMeshes3.length = 0;
  for (const ch of chests) {
    const sc = ch.gradeScale || 0.4;
    const mat = new THREE.MeshLambertMaterial({
      color: ch.gradeColor || 0xc8a030,
      emissive: ch.gradeEmissive || 0x221000
    });
    const m = new THREE.Mesh(new THREE.BoxGeometry(U*sc, U*sc*0.7, U*sc), mat);
    m.position.set(ch.wx, U*sc*0.35, ch.wy);
    m.castShadow = true;
    scene3.add(m);
    chestMeshes3.push(m);

    // ç­‰çº§æ ‡ç‰Œï¼ˆå°ç«–æ†ï¼‰
    const pillarMat = new THREE.MeshBasicMaterial({ color: ch.gradeColor || 0xc8a030 });
    const pillar = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, U*0.6, 6), pillarMat);
    pillar.position.set(ch.wx, U*sc*0.7+U*0.3, ch.wy);
    scene3.add(pillar);
    chestMeshes3.push(pillar);
  }
}

// â”€â”€ ç›¸æœºæ›´æ–° â”€â”€
function updateCamera3(dt) {
  const angleRad = Math.max(5, camAngle3) * Math.PI / 180;
  const camDist  = camHeight3 / Math.tan(angleRad);

  // ç›¸æœºå§‹ç»ˆè·Ÿéšç©å®¶XZï¼Œé«˜åº¦å›ºå®šä¸è·Ÿåœ°å½¢èµ°
  const targetX = player.wx;
  const targetY = camHeight3;          // å›ºå®šé«˜åº¦ï¼Œä¸éšç©å®¶Yåç§»
  const targetZ = player.wy + camDist;

  camera3.position.x += (targetX - camera3.position.x) * Math.min(1, 8 * dt);
  camera3.position.y += (targetY - camera3.position.y) * Math.min(1, 8 * dt);
  camera3.position.z += (targetZ - camera3.position.z) * Math.min(1, 8 * dt);
  camera3.up.set(0, 1, 0);                   // é”å®šä¸Šæ–¹å‘ï¼Œé˜²æ­¢ roll
  camera3.lookAt(player.wx, 0, player.wy);
  camera3.rotation.z = 0;                    // å¼ºåˆ¶æ¶ˆé™¤ roll åˆ†é‡

  // å…‰æºè·Ÿéš
  const ld = 800;
  sun3.position.set(player.wx + ld*0.5, camHeight3 * 1.2, player.wy - ld*0.3);
  sunTarget3.position.set(player.wx, 0, player.wy);
}

// â”€â”€ æ»‘åŠ¨æ¡åˆå§‹åŒ– â”€â”€
function initCamControls3() {
  const slH = document.getElementById('sl-h');
  const slA = document.getElementById('sl-a');
  const slZ = document.getElementById('sl-z');
  if (!slH) return;
  slH.addEventListener('input', () => {
    camHeight3 = parseFloat(slH.value);
    document.getElementById('val-h').textContent = camHeight3;
  });
  slA.addEventListener('input', () => {
    camAngle3 = parseFloat(slA.value);
    document.getElementById('val-a').textContent = camAngle3;
  });
  slZ.addEventListener('input', () => {
    orthoSize3 = parseFloat(slZ.value);
    document.getElementById('val-z').textContent = orthoSize3;
    updateFrustum3();
  });
  [slH,slA,slZ].forEach(s => s.addEventListener('keydown', e => e.stopPropagation()));
}

// â”€â”€ å°åœ°å›¾ï¼ˆä»ç”¨2D canvasï¼‰ â”€â”€
function drawMinimap3() {
  const mm = mmCtx, mw = 90, mh = 90;
  const sxr = MAP_W/mw, syr = MAP_H/mh;
  mm.fillStyle = '#0a0a14'; mm.fillRect(0,0,mw,mh);
  for (let r=0;r<ROWS;r+=2) for (let c=0;c<COLS;c+=2) {
    if (!tileMap[r]) continue;
    const t = tileMap[r][c];
    const elv = elevMap[r]?.[c]||0;
    const isRamp = slopeMap[r]?.[c]==='ramp';
    mm.fillStyle = t===1?'#1e1e2a':elv>=1?'#4a6070':isRamp?'#3a5060':'#2a2a38';
    mm.fillRect(c*TILE/sxr, r*TILE/syr, TILE/sxr+0.5, TILE/syr+0.5);
  }
  mm.fillStyle='#f87171'; enemies.forEach(e=>mm.fillRect(e.wx/sxr-1,e.wy/syr-1,2,2));
  mm.fillStyle='#4ade80'; mm.fillRect(extractPoint.wx/sxr-2,extractPoint.wy/syr-2,4,4);
  const gradeClr={'S':'#ffd700','A':'#818cf8','B':'#94a3b8'};
  chests.forEach(ch=>{if(!ch.opened){mm.fillStyle=gradeClr[ch.grade]||'#fbbf24';mm.fillRect(ch.wx/sxr-1,ch.wy/syr-1,3,3);}});
  mm.fillStyle='#fff'; mm.beginPath(); mm.arc(player.wx/sxr,player.wy/syr,3,0,Math.PI*2); mm.fill();
  // è§†å£æ¡†
  const ar = camHeight3 / Math.tan(Math.max(5,camAngle3)*Math.PI/180);
  const vw = orthoSize3*2*ASPECT3/sxr, vh = orthoSize3*2/syr;
  mm.strokeStyle='rgba(255,255,255,0.3)'; mm.lineWidth=1;
  mm.strokeRect(player.wx/sxr - vw/2, player.wy/syr - vh/2, vw, vh);
}

// â”€â”€ æ¸²æŸ“ä¸€å¸§ â”€â”€
function render3(dt) {
  syncEntities3();
  updateCamera3(dt);
  drawMinimap3();
  renderer3.render(scene3, camera3);
}
function loop(ts){
  const dt=Math.min((ts-lastTime)/1000,.05);lastTime=ts;frames++;

  if(gameState==='playing'){
    let dx=0,dy=0;
    if(keys['w']||keys['arrowup'])dy-=1;
    if(keys['s']||keys['arrowdown'])dy+=1;
    if(keys['a']||keys['arrowleft'])dx-=1;
    if(keys['d']||keys['arrowright'])dx+=1;
    const[tdx,tdy]=getTouchMove();dx+=tdx;dy+=tdy;
    if(dx||dy){
      const[nx,ny]=normalize(dx,dy);
      const nx2=player.wx+nx*player.spd,ny2=player.wy+ny*player.spd;
      if(!isSolid(nx2,player.wy))player.wx=nx2;
      if(!isSolid(player.wx,ny2))player.wy=ny2;
    }

    // Elevation jump animation
    const curElev=getElev(player.wx,player.wy);
    if(curElev!==player.prevElev){
      player.elevAnimT=0;
      player.elevAnimDir=curElev>player.prevElev?1:-1;
      player.prevElev=curElev;
    }
    if(player.elevAnimT<1){
      player.elevAnimT=Math.min(1,player.elevAnimT+dt*5);
      // Bounce curve: goes up then settles
      const t=player.elevAnimT;
      const bounce=Math.sin(t*Math.PI)*0.5*(1-t);
      player.visualBounce=bounce*14*player.elevAnimDir;
    } else {
      player.visualBounce=0;
    }

    playerShoot(dt);
    updateEnemies(dt);
    updateProjectiles(dt);
    updatePickup(dt);

    for(const p of particles){p.wx+=p.vx;p.wy+=p.vy;p.vy+=.04;p.life-=dt*.9;}
    particles=particles.filter(p=>p.life>0);

    updateCamera();
    checkExtract();

    // Respawn
    if(enemies.length<CONFIG.ENEMY_MAX){
      for(let i=0;i<CONFIG.ENEMY_RESPAWN;i++){
        let wx,wy,tries=0;
        do{wx=100+Math.random()*(MAP_W-200);wy=100+Math.random()*(MAP_H-200);tries++;}
        while((isSolid(wx,wy)||dist(wx,wy,player.wx,player.wy)<280)&&tries<40);
        const t=ENEMY_TYPES[Math.floor(Math.random()*ENEMY_TYPES.length)];
        const drops2=rollEnemyDrops(ENEMY_TYPES[Math.floor(Math.random()*ENEMY_TYPES.length)]);
        const eq2 = (()=>{
          const pool = t._dropWandIds && t._dropWandIds.length
            ? t._dropWandIds.map(id=>WANDS.find(w=>w.id===id)).filter(Boolean) : [];
          return pool.length ? Object.assign({},pool[Math.floor(Math.random()*pool.length)]) : null;
        })();
        const eDmg2   = eq2 ? (eq2.dmg[0]+eq2.dmg[1])/2 : t.dmg;
        const eRange2 = eq2 ? eq2.range : (t.range||60);
        const eRate2  = eq2 ? eq2.spd   : (t.attackRate||1.0);
        const eColor2 = eq2 ? eq2.proj   : t.color;
        enemies.push({wx,wy,hp:t.hp,maxHp:t.hp,spd:t.spd,dmg:eDmg2,color:t.color,projColor:eColor2,r:t.r,name:t.name,
          elev:getElev(wx,wy),attackCd:0,attackRate:eRate2,aggroRange:t.aggroRange||200,wanderAngle:Math.random()*Math.PI*2,
          drops:drops2,slowTimer:0,dotTimer:0,ranged:eq2?true:(t.ranged||false),range:eRange2,wand:eq2,phase:0});
      }
    }
  }else if(gameState==='dead'){
    for(const p of particles){p.wx+=p.vx;p.wy+=p.vy;p.vy+=.05;p.life-=dt*.5;}
    particles=particles.filter(p=>p.life>0);
    updateCamera();
  }

  if(gameState==='playing'||gameState==='dead'){
    render3(dt);
  }

  requestAnimationFrame(loop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT â€” å…ˆåŠ è½½ gamedata.jsonï¼Œå†å¯åŠ¨æ¸¸æˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initGame(){
  refreshMarket();
  initJoystick();
  requestAnimationFrame(ts=>{lastTime=ts;requestAnimationFrame(loop);});
  initAuth();
}
// å¯åŠ¨ï¼šåŠ è½½æ•°æ® â†’ initGame()
loadGameData();
</script>
</body>
</html>